# VMT v1.1 Overview and Next Steps

## Project Overview and Current State (v1.1)

Visualizing Microeconomic Theory (VMT) is an agent-based “microeconomic lab” where heterogeneous agents forage for resources and barter goods, allowing economic concepts like supply & demand or equilibrium to **emerge** from simulations. The current version **v1.1** (as of October 2025\) provides a solid foundation: a **deterministic 7-phase tick engine** (Perception → Decision → Movement → Trade → Regeneration → etc.) where agent interactions are fully reproducible given the same initial state. In v1.1, agents with configurable utility functions (CES or linear) successfully engage in **bilateral barter** trades and sustainable foraging. Key innovations bridge theory and implementation – e.g. a **discrete price-search algorithm** finds mutually beneficial integer trade ratios (resolving the gap between continuous marginal utility theory vs. indivisible goods). Mechanisms like a **trade cooldown** prevent infinite negotiation loops, and a **resource regeneration cycle** ensures renewable foraging dynamics. The infrastructure is production-quality: v1.1 introduced a high-efficiency **SQLite telemetry logging system** (\~99% data size reduction) and a **PyQt5 GUI** for scenario creation/launch, making the simulator more robust and user-friendly. The codebase is safeguarded by 50+ tests and deterministic design choices (fixed agent ordering, one trade per pair per tick, etc.), yielding a reliable baseline to build upon. In short, VMT v1.1 demonstrates a working barter economy with clear, reproducible outcomes – an excellent springboard for adding more complex economic features.

## Immediate Focus: Polishing the v1.1 Core

Before moving on to new features, the **v1.1 engine must be thoroughly polished and documented** as a clean base. The goal is to eliminate any ambiguity in the current system and finalize v1.1. Key tasks for this polish phase include:

* **Author an Engine Overview:** Write a concise README or technical guide (within the vmt\_engine module) explaining the engine’s design. Document the **7-phase tick cycle** and the role of each subsystem each tick (perception, decision, matching/trade, etc.). This narrative will serve as quick-reference documentation, ensuring any contributor (or your future self) can easily grasp how the barter simulation operates step-by-step.

* **Improve Code Clarity with Comments:** Do a pass through complex code sections – especially the trading logic in systems/matching.py and systems/quotes.py, and the utility calculations in econ/utility.py – and add explanatory comments. Clarify the rationale behind non-obvious design choices (e.g. why ties in agent order are broken by lower ID for determinism, how the price search algorithm works in practice, etc.). These annotations will make the code more maintainable and reduce ramp-up time after any breaks.

* **Create a Canonical Example Scenario:** Develop a **foundational barter demo** (e.g. a YAML scenario file like scenarios/foundational\_barter\_demo.yaml) that showcases the core v1.1 setup. Populate it with a simple but illustrative world (a few agents with complementary endowments/preferences) and include **extensive comments** in the scenario file explaining each parameter. This serves as a tutorial-by-example: by reading and running this scenario, one can learn how to configure a basic exchange economy in VMT and understand expected outcomes. (Embedding such explanation in the scenario file keeps documentation close to the actual usage.)

* **Add an Integration Test for the Demo:** Write a long-run integration test (e.g. test\_foundational\_scenario.py) that loads the above scenario and runs the simulation for a fixed number of ticks. The test should verify key invariants and outcomes – for example, ensure no goods are created or destroyed (total quantities conserved), that all possible mutually beneficial trades actually occur, or that certain known trade outcomes happen given the setup. This end-to-end test will guard against regressions: as new features get introduced, running it will confirm the core barter behavior remains correct and unchanged.

* **Tidy Up Remaining Loose Ends:** Address any minor fixes needed to declare v1.1 truly “finished”. This includes clearing out TODO comments or temporary hacks in the code, ensuring all unit tests (and the new integration test) pass consistently, and doing a final sweep for clean code style (consistent naming, formatting, documentation). The aim is that after this polish, the **v1.1 codebase is stable, well-documented, and trusted** – a platform with zero known issues or uncertainties. This will give confidence as we embark on more ambitious extensions.

## Next Steps: Money & Market Exchange (Planning Phase)

With a polished barter engine in hand, the project’s next major milestone is introducing **money and market-based price exchange** mechanisms to evolve beyond pure barter. These features (which are notably absent in v1.1’s barter-only economy) will bring VMT closer to a full microeconomic simulator – enabling agents to face budget constraints and allowing prices to emerge from multi-agent interactions (not just pairwise trades). However, both “money” and many-to-many market trading add conceptual and technical complexity. **Before writing any code, the plan is to prepare two guiding documents**: a **Theoretical Foundation** document and an **Implementation Planning** document. Following the “Living Blueprint” approach, these documents will live in the repository (under version control) and evolve alongside the code, ensuring strategic clarity and technical direction are well-aligned. Below is an outline of what to cover in each document (and tasks to produce them):

### Theoretical Foundation Document (Money & Markets)

This document will articulate the **economic theory and design reasoning** behind adding money and market mechanisms to VMT. Key sections and tasks for this comprehensive write-up:

* **Economic Role of Money:** Research and explain the microeconomic rationale for introducing a monetary medium of exchange. Describe how, in theory, money alleviates the limitations of barter by enabling **indirect exchange** and enforcing **budget constraints** on agents. Connect this to VMT’s context: e.g. under barter an agent lacking a needed good can’t trade, but with money they can sell what they have for money then buy what they need. Emphasize that money in the simulation will allow more complex multi-good exchange patterns and will mimic a basic consumer budget scenario (income \= money) which was previously missing.

* **Utility Model for Money:** Lay out the theoretical options for modeling how agents derive utility from holding money. The near-term plan is to adopt a **quasi-linear utility** model where money provides a constant marginal utility (value λ per unit). Explain this choice in theoretical terms: it mirrors textbook assumptions that each dollar yields a fixed utility (simplifying analysis) and ensures agents always value more money at a steady rate. Also note the planned future alternative (for completeness): an **instrumental value** model (money with no direct utility, valued only for what it can buy). Clarify why the simpler **Option A: λ \* M utility** is chosen initially (educational clarity and ease of implementation), and how it will still allow exploration of monetary phenomena. The document should tie this back to economic concepts of utility and budget constraints, justifying that the simulation’s approach is grounded in theory.

* **Market Mechanism Concept:** Describe the shift from bilateral trades to a **market price formation mechanism** in the simulation. In economic theory, markets aggregate many buyers and sellers to determine a price where supply meets demand. For VMT, outline how a **posted-price market or auction** within a group of agents would work: agents post their willingness to pay/accept, and the system finds a single clearing price for all. Explain the theoretical underpinnings of this: e.g. how it relates to partial equilibrium in a small market, the idea of an “invisible hand” setting an equilibrium price, and how this differs from sequential pair trades. Include references to classic mechanisms like double auctions or Walrasian tatonnement in simplifying terms, to ground the approach in known economic models. The goal is to illustrate what economic phenomenon we intend to capture (a microcosm of a competitive market) and why it’s valuable for users to **see a market-clearing price emerge** rather than just negotiated barter outcomes.

* **Educational and Research Implications:** Conclude the theoretical doc by discussing **why these features matter** for the project’s mission. For example, adding money enables demonstration of consumer choice under budget constraints and the concept of a numeraire, aligning with textbook microeconomics. Adding a market mechanism will let users observe supply-demand equilibrium price formation and market efficiency or failures in action. Stress how these additions support both *Educational Mode* (more textbook-aligned scenarios like market equilibrium graphs) and *Research Mode* (experimenting with emergent price dynamics, liquidity, etc.). This section solidifies the justification for the upcoming work, ensuring it stays true to VMT’s vision of bridging rigorous theory with interactive visualization.

### Implementation Planning Document (Money & Markets)

This second document will translate the above theory into a concrete development plan. It should function as a technical roadmap for implementing money and market exchange features step-by-step, while preserving VMT’s core principles (determinism, clarity, testability). Key items to include:

* **Engine Changes for Money:** Outline how the codebase will represent and handle money. Plan to **extend agent inventories** and state to include a money balance (e.g. a third resource “M”) and update scenario definitions to allow initial money endowments for agents. Specify how the **utility calculation** will be extended to include a money term: likely by adding \+λ \* M to each agent’s utility function (with λ configurable per scenario or globally). This section should enumerate all modules to touch – e.g. scenario schema (to input money amounts), econ/utility.py (to compute utility with money), and any constants or parameters for λ. Essentially, we’re treating money as another consumable good (except it’s not produced or foraged) in the engine.

* **Integrating Money into Trading Logic:** Describe modifications to the negotiation/matching systems so that agents can trade goods for money seamlessly. The plan is to **treat money as a tradable good** in the existing reservation price and quote system. Concretely, when money is present, each agent would consider bids/asks for exchanging money ↔ good A or money ↔ good B (in addition to the existing A↔B barter quotes). The matching algorithm can then pair a buyer with money and a seller of a good (or vice versa) using the same price-search mechanism as before. Highlight that **determinism must be preserved** – e.g. use the same sorted agent ordering, and the price rounding logic remains unchanged for money trades. Also note that money will **not be forageable** or created from thin air (no resource spawns for M), so all money in circulation comes from initial endowments or later, possibly from some fixed external "bank" if scenarios allow (though none planned now). The document should reassure that adding money won’t introduce randomness or undermine the one-trade-per-tick rule (each pair or group still only executes one exchange per tick).

* **Testing Strategy for Money:** Lay out how the money feature will be verified. Plan unit tests for utility functions (e.g. **\+1 money yields \+λ utility** exactly, no diminishing returns) and for trading logic (agents shouldn’t trade in a way that creates or destroys money – check conservation of total money in transactions). Include edge cases: an agent with money but no goods can’t increase utility unless goods become available (money’s value is zero if there’s nothing to buy). Also, design an integration test where a simple scenario with money runs and we assert expected outcomes (like an agent with money successfully facilitates a trade between two others who wouldn’t barter directly). This ensures the introduction of money strictly increases the simulation’s capabilities without breaking existing barter behaviors.

* **Telemetry and UI Updates:** Note the changes needed to support money in logging and visualization. The logging system should record when **trades involve money** – possibly by adding a flag or listing the goods in each trade record (so one can filter or analyze money-mediated trades). We may track each agent’s money holdings over time as part of the state logs to observe the “velocity” or distribution of money. The GUI will need a tweak to display agents’ money balances (e.g. in a sidebar or info panel), while we likely **won’t visualize money on the grid** (unlike goods which appear in the environment). Planning these adjustments in advance ensures that once money is implemented, the tooling will fully support it (and we maintain the project’s emphasis on insight via telemetry).

* **Demo Scenario for Money:** Define a new example scenario (e.g. money\_quasilinear\_demo.yaml) to showcase money in action. For instance, imagine three agents: one initially holding only Good A, another only Good B, and a third holding only money – with all having appropriate utility preferences. Describe how the simulation should play out (the money-holder will buy A from the first agent and B from the second, enabling indirect exchange between the other two). The planning document should outline this scenario’s design and purpose: to **confirm that agents value money enough to trade goods for it**, and then use that money to obtain other goods, demonstrating that money can successfully mediate trades that barter could not achieve. This will serve as both a test and a tutorial example once the feature is ready.

* **Local Market Grouping & Price Discovery:** When moving to a market mechanism, specify how the engine will identify a market and determine a price. Plan to leverage agent positions or connectivity to form **trade groups each tick** – e.g. all agents within interaction range form a “local market” component. If a group has more than 2 agents, instead of doing sequential pair trades, the engine will invoke a market clearing process for that group. Detail the **posted-price algorithm** to use: for simplicity, start with one good at a time priced in money. Aggregate all sellers’ asks and buyers’ bids for, say, Good A (in terms of money) and find a single clearing price – for example, identify the lowest ask and highest bid and choose a price in between (midpoint or even just the lowest ask to be deterministic). Clarify tie-break rules to keep it deterministic (if multiple agents share the same highest bid, use a fixed rule like lowest agent ID to prioritize). The document should map out this mechanism step-by-step: from perception (agents formulate quotes) → grouping (find clusters) → price calculation → trade matching. Essentially, we are planning a **single-price auction per good** for each group, which should emulate a basic supply-demand intersection in that micro market.

* **Design of Market Trade Execution:** Explain how trades will be executed once a market price is set. Unlike bilateral trade (one buyer, one seller), a market could have many participants. We will allow **multiple agents to trade at the same clearing price within the same tick**, but **each agent still executes at most one trade** in that tick to preserve the turn-based simplicity. For instance, after setting the price, we can sort potential traders and match buyers to sellers one-by-one (perhaps pairing the lowest-ID buyer with lowest-ID seller first, executing one lot trade, then move to the next, etc.). Continue until no more trades can happen at that price or until every agent has traded once. This ensures fairness and constraint (no single agent hogs multiple trades in one tick) while allowing the market to clear as much as possible. The plan should note that the usual **ΔU \> 0** condition still applies for each executed trade – if the uniform market price would cause a particular pair to have no utility gain, that trade simply doesn’t occur for that pair. Thus, the market mechanism becomes a layer atop the barter logic: it finds a common price and then lets through any trades that are mutually beneficial at that price. By designing it this way, we uphold individual rationality and stay consistent with the economic idea that trades only happen if both sides gain utility.

* **Testing the Market Mechanism:** Devise a testing approach to validate that the market feature works as intended and doesn’t introduce anomalies. One plan is to construct a deterministic scenario (say 3–5 agents in one market group with known endowments and preferences) where we can analytically predict the equilibrium price and outcome. The test would check that the simulation finds the same clearing price and allocates trades accordingly. Also, include a comparison or fallback: for a small group, the market outcome should be consistent with what sequential optimal bilateral trades would have achieved (or at least no agent is worse off than in bilateral trading). Critically, **re-run the existing test suite** (especially the foundational barter integration test) with the market mechanism toggled on vs. off to ensure no regressions. The planning document should list specific invariants to watch: e.g., determinism (the market produces identical results on repeated runs), conservation of total goods and money, and each agent’s utility never decreases due to participating in the market. By outlining these tests now, we set clear success criteria for the implementation phase.

* **Telemetry & Demo for Markets:** Plan enhancements to the logging and examples to accompany the market feature. The telemetry should record **market events** per tick – for each market group, log the clearing price and how many trades occurred (and maybe which agents traded). This will allow analysis like plotting the price over time to see convergence or volatility. Additionally, propose a **demonstration scenario for the market mechanism** (could adapt an existing scenario or create a new one). For example, a scenario with 4–5 agents all in range forming a single market: some primarily holding Good A, others Good B, and some money – run this and observe how a uniform price for A (in money) emerges and multiple trades occur at that price. Such a scenario would vividly show the difference between scattered barter transactions and a centralized market clearing process. Documenting this scenario now will guide implementation and later serve as a tutorial (e.g. “Market Day” scenario demonstrating basic supply-demand equilibrium in action).

Finally, both the theoretical and planning documents should be maintained as **living documents in the repo** (per the Living Blueprint philosophy). They will evolve alongside the code: as design decisions firm up or change during implementation, update these files so that they remain the single source of truth connecting the project’s strategic goals to its technical execution. By completing the above to-do list, you’ll have a crystal-clear understanding of what to build and why – setting yourself up for a focused and productive development phase on VMT’s next version. Good luck, and happy coding\! 

---

 README.md

[https://github.com/cmfunderburk/vmt-dev/blob/907dc6895ca3ecdef4cee9d3adf3774929fec776/README.md](https://github.com/cmfunderburk/vmt-dev/blob/907dc6895ca3ecdef4cee9d3adf3774929fec776/README.md)

  Planning Document Guideline Creation.md