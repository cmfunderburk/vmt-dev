# VMT Project Overview and Planning Document
## Generated by Claude Opus for Development Session
*Date: October 16, 2025*
*Purpose: Mindset preparation and productivity roadmap*

---

## Current Project State Summary

### What We Have Achieved (v1.1)
The VMT project has successfully established a **robust foundation for agent-based microeconomic simulation**. The current implementation demonstrates:

1. **Core Engine Architecture:** 
   - Deterministic 7-phase tick cycle (Perception → Decision → Movement → Trade → Forage → Resource Regeneration → Housekeeping)
   - Spatial grid with resource spawning and regeneration
   - Agent-based simulation with heterogeneous utility functions (CES and Linear)
   - Bilateral barter trading with sophisticated price discovery

2. **Key Technical Innovations:**
   - Compensating discrete price search algorithm (bridges theory-practice gap)
   - Trade cooldown system (prevents infinite negotiation loops)
   - Zero-inventory epsilon adjustment (handles edge cases elegantly)
   - Resource regeneration with cooldown (sustainable foraging dynamics)
   - One-trade-per-tick rule (pedagogical clarity)

3. **Infrastructure Excellence:**
   - SQLite telemetry system with ~99% space savings over CSV
   - PyQt5 log viewer for analysis
   - 54+ automated tests covering edge cases
   - GUI launcher and scenario builder
   - Deterministic simulation with reproducible results

### Where We Are Going
The vision is to transform VMT from its current **bilateral barter economy** into a **comprehensive microeconomic laboratory** that can simulate:
- Money and budget constraints
- Market mechanisms (posted prices, auctions)
- Production economies with firms
- General equilibrium
- Information economics and mechanism design

---

## Today's Mission: V1.1 Polish & Theoretical Foundation

### Primary Objective
Complete the v1.1 polish phase while establishing the **theoretical and planning foundation** for the money/market features. This is NOT about implementation yet, but about creating the intellectual scaffolding that will guide future development.

### Why This Matters
Per the Living Blueprint philosophy from `Planning Document Guideline Creation.md`, we need to:
1. **Document what exists** - Make the current engine crystal clear
2. **Plan what's next** - Create rigorous theoretical foundation BEFORE coding
3. **Maintain alignment** - Ensure every task connects to the grand vision

---

## Detailed Task Breakdown

### Section 1: V1.1 Polish Tasks (Immediate Priority)

#### 1.1 Engine Documentation (`vmt_engine/README.md`)
**Goal:** Create a clear, technical overview of how the engine works.

**Contents to Include:**
```markdown
# VMT Engine - Technical Overview

## Architecture Overview
- 7-phase tick cycle explanation with diagram
- Determinism guarantees and ordering rules
- Data flow between systems

## Core Systems
### Perception System
- Frozen snapshot mechanism
- Vision radius and information gathering

### Decision System  
- Forage target selection (ΔU * β^dist scoring)
- Trade partner selection (surplus overlap)

### Movement System
- Manhattan distance pathfinding
- Deterministic tie-breaking rules

### Trading System
- Quote generation (reservation bounds + spread)
- Price search algorithm
- Trade execution and inventory updates

### Resource System
- Foraging mechanics
- Regeneration with cooldown
- Conservation laws

## Key Algorithms
### Price Discovery
- Discrete price search with rounding
- Compensating multi-lot scanning
- ΔU > 0 enforcement

### Utility Calculations
- CES/Linear utility evaluation
- Zero-inventory epsilon guard
- Reservation price computation

## Invariants
- Total goods conservation
- Non-negative inventories
- Deterministic agent ordering
```

#### 1.2 Foundational Scenario (`scenarios/foundational_barter_demo.yaml`)
**Goal:** Create a heavily commented tutorial scenario.

**Key Elements:**
- Start with exactly 3 agents (minimal complexity)
- Clear initial endowments that lead to obvious trades
- Extensive inline comments explaining each parameter
- Expected outcomes documented

```yaml
# Foundational Barter Demo - Tutorial Scenario
# This scenario demonstrates the core bilateral barter mechanics
# with carefully chosen parameters for educational clarity

schema_version: 1
name: foundational_barter_demo

# Grid size - small enough to ensure agents interact
N: 10  

# Number of agents - minimal for clear bilateral trades
agents: 3

# Initial inventories - chosen to create obvious gains from trade
# Agent 0: Has lots of A, needs B (will sell A)
# Agent 1: Has lots of B, needs A (will sell B)  
# Agent 2: Balanced, will trade opportunistically
initial_inventories:
  A: [10, 2, 6]
  B: [2, 10, 6]

# [Continue with detailed parameter explanations...]
```

#### 1.3 Integration Test (`tests/test_foundational_scenario.py`)
**Goal:** End-to-end test that validates core behavior remains stable.

**Test Structure:**
```python
def test_foundational_scenario_determinism():
    """Verify foundational scenario produces expected deterministic results."""
    # Load scenario
    # Run for exactly 20 ticks with seed=42
    # Assert specific trades occurred
    # Assert total conservation
    # Assert final state matches expected
```

#### 1.4 Code Annotation Pass
**Focus Areas:**
- `matching.py` - Explain tie-breaking and partner selection
- `quotes.py` - Document reservation price logic
- `utility.py` - Clarify MRS calculations and epsilon handling
- `simulation.py` - Document phase ordering rationale

---

### Section 2: Theoretical Foundation Document

#### 2.1 Document: `PLANS/theory/Money_and_Markets_Theoretical_Foundation.md`

**Purpose:** Establish the economic theory that will guide implementation.

**Outline:**
```markdown
# Theoretical Foundation for Money and Market Mechanisms in VMT

## Part I: Money in Agent-Based Economies

### 1.1 The Role of Money
- Medium of exchange vs store of value
- Money as solving the "double coincidence of wants" problem
- Fiat money in simulation environments

### 1.2 Utility Specifications for Money
#### Option A: Quasilinear Utility (v1.x approach)
- U(A,B,M) = U(A,B) + λM
- Constant marginal utility of money
- Implications for agent behavior
- When this approximation is valid

#### Option B: Instrumental Value (future)
- Money has no intrinsic utility
- Value derived from purchasing opportunities
- Shadow price calculation (λ_hat)
- Dynamic money valuation

### 1.3 Budget Constraints
- Hard constraints vs soft preferences
- Integer constraints in discrete goods
- Relationship to reservation prices

## Part II: Market Mechanisms

### 2.1 From Bilateral to Multilateral Trade
- Limitations of pairwise matching
- Benefits of common prices
- Market efficiency considerations

### 2.2 Posted-Price Markets
- Price determination algorithms
- Order book mechanics
- Market clearing conditions
- Rationing when supply ≠ demand

### 2.3 Auction Mechanisms
- Discrete double auctions
- First-price vs second-price
- Walrasian tatonnement approximation

## Part III: Integration Challenges

### 3.1 Maintaining Determinism
- Order of operations in markets
- Tie-breaking in price setting
- Agent processing sequences

### 3.2 Discrete Goods Problem
- Rounding in monetary transactions
- Price granularity issues
- Integer programming aspects

### 3.3 Behavioral Consistency
- Agent rationality requirements
- Learning and adaptation
- Strategic vs myopic behavior
```

#### 2.2 Document: `PLANS/implementation/Money_Markets_Implementation_Plan.md`

**Purpose:** Bridge theory to practice with concrete implementation strategy.

**Structure:**
```markdown
# Implementation Planning for Money and Markets

## Phase 1: Money Introduction (v1.3)

### Data Model Changes
- Extend Inventory to include M field
- Update Quote to handle money trades
- Scenario schema for money parameters

### Utility System Updates
```python
class QuasilinearWrapper:
    """Wraps existing utility with money term."""
    def __init__(self, base_utility: Utility, lambda_money: float):
        self.base = base_utility
        self.lambda_m = lambda_money
    
    def evaluate(self, inv: Inventory) -> float:
        return self.base.evaluate(inv) + self.lambda_m * inv.M
```

### Quote Generation for Money
- Reservation price for A in M: MU_A / λ
- Bid-ask spread application
- Cross-good quote matrix

### Testing Strategy
- Money conservation tests
- Utility accounting validation
- Trade execution with money

## Phase 2: Posted-Price Markets (v1.4)

### Component Detection
```python
def find_market_components(agents: list[Agent], 
                          interaction_radius: int) -> list[set[int]]:
    """Find connected components of agents within trading range."""
    # Union-find or BFS approach
    # Return list of agent ID sets
```

### Price Determination
```python
def determine_market_price(quotes: list[Quote]) -> Optional[float]:
    """Find market-clearing price from agent quotes."""
    # Sort asks ascending, bids descending
    # Find crossing point
    # Apply deterministic tie-breaking
```

### Market Execution
```python
def execute_market_trades(component: set[int], 
                         price: float,
                         agents: dict[int, Agent]):
    """Execute trades at market price."""
    # Match buyers and sellers
    # One trade per agent constraint
    # Verify ΔU > 0 for each trade
```

## Phase 3: Integration Considerations

### Mode Scheduling (v1.2 prerequisite)
- Forage-only vs trade-only phases
- Creates implicit budget constraints
- Natural lead-in to money

### Telemetry Extensions
- Money flow tracking
- Market price time series
- Trade volume metrics

### Performance Implications
- Component detection complexity: O(n²) worst case
- Market matching: O(n log n) per component
- Acceptable for educational scenarios (n < 100)
```

---

## Today's Execution Plan

### Morning Session: V1.1 Polish (2-3 hours)
1. **Create `vmt_engine/README.md`**
   - [ ] Write architecture overview section
   - [ ] Document each system's responsibility
   - [ ] Explain key algorithms
   - [ ] List invariants and guarantees

2. **Create `scenarios/foundational_barter_demo.yaml`**
   - [ ] Design clear 3-agent scenario
   - [ ] Add extensive inline comments
   - [ ] Document expected outcomes
   - [ ] Test scenario manually

3. **Implement `tests/test_foundational_scenario.py`**
   - [ ] Write determinism test
   - [ ] Add conservation assertions
   - [ ] Verify specific trades occur
   - [ ] Ensure backward compatibility

### Afternoon Session: Theoretical Foundation (2-3 hours)
1. **Draft Money Theory Document**
   - [ ] Outline utility specifications
   - [ ] Compare quasilinear vs instrumental
   - [ ] Document budget constraint handling
   - [ ] Address integer money issues

2. **Draft Market Theory Document**
   - [ ] Explain posted-price mechanism
   - [ ] Detail price determination
   - [ ] Address rationing problems
   - [ ] Compare to bilateral baseline

### Evening Session: Implementation Planning (1-2 hours)
1. **Create Implementation Plan**
   - [ ] Map theory to code structure
   - [ ] Design data model changes
   - [ ] Outline testing strategy
   - [ ] Identify risk areas

2. **Review and Refine**
   - [ ] Cross-check with VMT v2 planning doc
   - [ ] Ensure alignment with Living Blueprint philosophy
   - [ ] Update main planning doc if needed

---

## Success Criteria for Today

### V1.1 Polish Complete When:
- [ ] Engine has clear technical README
- [ ] Foundational scenario exists and is well-documented
- [ ] Integration test guards against regressions
- [ ] Complex code sections have explanatory comments

### Theoretical Foundation Complete When:
- [ ] Money utility models are rigorously specified
- [ ] Market mechanisms are theoretically grounded
- [ ] Discrete goods challenges are addressed
- [ ] Determinism preservation strategy is clear

### Implementation Plan Complete When:
- [ ] Theory maps cleanly to code architecture
- [ ] Data model changes are specified
- [ ] Testing strategy covers edge cases
- [ ] Risk areas are identified and mitigated

---

## Key Principles to Remember

1. **Documentation as Code**: All planning documents live in the repo and evolve with the code.

2. **Theory Before Practice**: Fully understand the economics before writing implementation.

3. **Determinism is Sacred**: Every design decision must preserve reproducibility.

4. **Educational Clarity**: Features should make economic concepts visible and understandable.

5. **Test-Driven Confidence**: Every feature needs tests that verify both correctness and determinism.

---

## Notes and Reminders

- The current v1.1 system is **solid** - don't break what works while polishing
- Money is conceptually simple but implementation has subtleties (integer constraints, utility specification)
- Markets introduce true complexity - component detection, price determination, and maintaining one-trade-per-agent
- Keep the dual mission in mind: Educational Mode (clear, textbook-like) vs Research Mode (realistic, emergent)
- The Living Blueprint philosophy means this planning work IS the project, not overhead

---

## Quick Reference Commands

```bash
# Run tests to ensure nothing breaks
pytest tests/ -v

# Test specific scenario
python main.py scenarios/foundational_barter_demo.yaml 42

# View telemetry after run
python view_logs.py

# Launch GUI for interactive testing
python launcher.py
```

---

*Remember: Today is about creating the intellectual foundation that will guide weeks of future implementation. Quality thinking now saves debugging time later.*
