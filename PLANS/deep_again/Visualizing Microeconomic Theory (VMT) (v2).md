# Visualizing Microeconomic Theory (VMT) – Comprehensive Planning Document (v2)

## Purpose and Philosophy

This document serves as the new **source-of-truth planning blueprint** for the Visualizing Microeconomic Theory (VMT) project, replacing the older Planning-Post-v1.md. It is a **living, narrative-style plan** that unifies high-level vision with actionable development guidance. The goal is to ensure all near-term work aligns with the ambitious original vision of VMT while providing concrete roadmaps and checklists for execution. As a solo developer project, this document is both a strategic guide and a practical to-do list, meant to be updated iteratively as the project evolves.

**VMT Vision Recap:** VMT is conceived as a **microeconomic laboratory** built on Agent-Based Computational Economics (ACE) principles. In essence, it functions like a "computational sandbox" where abstract microeconomic theories can be dynamically **simulated and visualized**. Instead of static equations on a page, users get an **interactive, simulation-driven environment** to experiment with economic concepts. The philosophy is *"visualization-first"* – turning textbook fables and equations into living, breathing experiments. By manipulating parameters and watching agents interact, students and researchers can observe phenomena like supply & demand or market equilibrium **emerge** from the bottom-up interactions of agents, much like observing a laboratory culture dish. This aligns with ACE's **bottom-up** paradigm: complex market outcomes (prices, allocations, etc.) are not imposed but **emerge organically** from individual agents' decisions. The platform is intended to support both an *Educational Mode* – where agents behave as perfectly rational textbook agents – and a *Research Mode* – where one can introduce bounded rationality, learning behavior, or randomness. Ultimately, the vision is to create a tool that bridges rigorous theory and intuitive insight, allowing users to "see" microeconomics in action as if running experiments in a virtual econ lab.

## Current State Review

**Foundation Achieved:** The project's current state (v1.1, *foraging + bilateral barter*) provides a **solid foundation** that demonstrates key microeconomic principles through agent-based simulation. In its narrow initial scope, VMT already functions as a **focused demo platform for bilateral exchange and foraging behavior**. Notably, the core engine is fully functional and was built with deterministic principles from the ground up, ensuring that given the same initial conditions it produces the same sequence of outcomes – a critical property for both educational reliability and scientific reproducibility.

**Key Achievements of v1.1:** The current implementation includes several components and innovations that underpin its success:

* **Robust Agent-Based Simulation Engine:** Heterogeneous agents (with configurable CES or linear utility preferences) move on a spatial grid, harvest resources, and engage in bilateral barter trades under a well-defined reservation price negotiation mechanism. The environment supports resource regeneration, and agents make decisions to maximize utility given their local information.

* **Deterministic, Clear System Behavior:** The core engine operates on a fixed multi-phase tick cycle (Perception → Decision → Movement → Trade → Forage → Resource Regeneration → Housekeeping) that is strictly ordered for determinism. All agent processing is done in a stable order (by ascending agent ID) and trade pair matching is deterministic (e.g. pairs sorted by agent IDs). A "frozen" snapshot of the world is used each tick for agent perception, preventing any mid-tick information leaks. These design choices ensure **system clarity** – the outcome of each tick is fully determined by initial state, and there is no randomness in the economic interactions.

* **Critical Technical Innovations:** The implementation introduced solutions to practical problems that theoretical models often gloss over:

* *Price Search Algorithm:* a **compensating discrete price search** that bridges the gap between continuous marginal rates of substitution (MRS) theory and the reality of indivisible goods. Instead of assuming fractional trades or perfect price divisibility, the engine searches for an integer trade quantity and price (rounded half-up) that yield mutual utility gains for both parties. This innovation solves a real computational problem and makes CES utility trades work in practice (an issue that standard theory doesn't address).

* *Trade Cooldown:* a **cooldown system** after failed trade attempts to prevent two agents from getting stuck in a ping-pong of offers that lead nowhere. This avoids infinite loops and unrealistic rapid trading cycles. It creates more realistic patterns (agents back off and try later), essentially introducing a temporal component to negotiation that yields emergent trade patterns.

* *Resource Regeneration Cooldown:* resources on the grid regenerate on a cooldown as well, ensuring sustainable foraging dynamics. This prevents agents from depleting a resource cell and then immediately exploiting it again, leading to more realistic cycles of scarcity and abundance.

* *Zero-Inventory Handling:* an elegant epsilon adjustment is used in utility calculations to handle cases of zero inventory without undefined MRS or division-by-zero issues. This was crucial for smooth functioning of CES utility when an agent has 0 of some good.

* *One-Trade-Per-Tick Simplification:* The engine limits each agent pair to at most one trade per tick. This rule, while simplifying the interaction, proved pedagogically valuable – it makes each trade event clear and discrete, and the simulation easier to follow, without sacrificing the possibility of reaching equilibrium over time.

* **Modern Infrastructure & Tooling:** Even at v1.1, the project adopted a **production-quality infrastructure** unusual for prototypes. There is a comprehensive **SQLite-based telemetry logging** system (with \~99% space savings over raw CSV logging) and a custom **PyQt5 log viewer** for interactively exploring simulation data after a run. A GUI launcher and scenario builder provide a user-friendly interface to configure and run simulations. Performance optimizations (like batched database writes and efficient spatial indexing) were implemented to handle larger simulations smoothly. Moreover, the project is backed by **54+ automated tests** covering economic correctness and edge cases – an unusually high test coverage that ensures engine reliability and guards against regressions.

**Exceeding Initial Expectations:** In several areas, the current implementation **surpasses the original plan**. For example, the sophisticated price-search trading algorithm and cooldown mechanisms were not foreseen in the initial vision documents, yet they solve real-world issues and add realism that a naïve implementation would lack. The data and logging infrastructure is far more advanced (telemetry database with viewer) than initially imagined, providing analysis capabilities of a professional-grade tool. The emphasis on testing and a GUI interface also make the platform more robust and accessible than one might expect from an academic prototype. In short, the project as it stands is **different and in many ways better** than the early vision in its core mechanics, albeit achieved by narrowing scope to focus on quality.

**Scope Limitations:** Naturally, the current version is also **narrower in scope** than the full vision of a comprehensive microeconomics simulator. Important economic features are not yet implemented. Notably, there is **no concept of money or budget constraints** – agents only trade goods by barter, so income effects and monetary exchange are absent. Likewise, the simulation is limited to **pairwise trades (no markets)**; there is no representation of market-wide price-setting, competition, or many-to-many trade interactions (each trade is a bilateral match). **Production and firms** are not present – currently it's a pure exchange economy with foraging, lacking any notion of agents producing goods or a labor/capital market. Higher-level topics like general equilibrium (multi-market clearing), **game theory** (strategic interaction beyond the implicit negotiation in trading), and **mechanism design** (auctions, social welfare, information economics) remain completely unimplemented. These gaps define the roadmap ahead: moving from the solid barter economy core to a more rich economic world with money, markets, production, and advanced topics.

## Architecture and Design Principles

From the beginning, VMT's engine was engineered with a clear set of **design principles** to ensure consistency, reproducibility, and extensibility. Here we outline the core architectural choices and data schema, and how they support the project's goals.

**Determinism & Reproducibility:** A cornerstone of the design is **determinism-first**. The simulation is meant to be fully deterministic given an initial random seed or scenario – a run can be exactly replicated step-by-step. This is achieved through strict ordering and tie-breaking conventions throughout the code: \- The simulation tick is broken into a fixed sequence of phases that never change order (presently: **Perception → Decision → Movement → Trade → Forage → Resource Regeneration → Housekeeping**). This rigid structure guarantees that all processes happen in a consistent, logical order each tick. \- All agents are processed in a fixed order (by ascending AgentID) whenever they act or are iterated over. Similarly, any pairwise interactions (like matching two agents for trade) are ordered by a deterministic key (e.g. ascending tuple of agent IDs). No use is made of unordered data structures where iteration could vary run-to-run; instead, lists and maps are kept sorted or keyed by stable identifiers at all times. \- Any situation that could produce ambiguity is resolved with deterministic rules. For example, if two potential trading partners have equal "best trade" score, the tie is broken by comparing their IDs (lower ID wins). Price calculations for trades use a consistent *round-half-up* rule for converting fractional prices to integer trade quantities. Agents always perceive a **snapshot** of the world frozen at the start of the tick (no mid-tick updates), eliminating order-of-actions effects. \- Randomness in initial scenario generation (e.g., assigning random initial inventories or resource locations) is controlled by explicit seeding in the scenario config. The YAML scenario files can specify distributions (uniform, etc.) for initial values, and because the engine processes agents in order, as long as the random number generator seed is fixed, those distributions yield the same assignment every run.

The determinism is not an arbitrary choice – it serves the educational mission by ensuring two students running the same scenario will see the same results (important for teaching demos), and it supports the research mission by making the simulation **fully reproducible** (critical for scientific experiments). It also makes testing far more rigorous: one can assert exact outcomes of a simulation after X ticks, knowing any code change that violates determinism or correctness will cause test failures. This discipline essentially treats the simulation as a deterministic state machine, which aligns with the goal of eventual migration to compiled languages or high-performance environments where reproducibility is required. (Indeed, the project's type definitions are written in a language-agnostic way to ease future re-implementation in Rust/Go/TypeScript with identical behavior.)

**Explicit Data Types & Schema:** The VMT engine relies on a well-defined schema of data types and contracts, documented in typing_overview.md. All key concepts of the model are formalized: \- **Core primitives:** Basic types like AgentID (int), Good (enum of goods "A", "B", etc.), Quantity (int for units of goods), Price (float for ratio, e.g. B per A), UtilityVal (float for utility values), Coord (grid coordinates), and Tick (simulation timestep) are defined with clear units and constraints (e.g. Quantity ≥ 0, ticks are non-negative ints, etc.). This provides a kind of pseudo-type-safety even in Python and ensures consistency in how data is represented (for example, **all inventories and resource amounts are integers** – the model treats goods as discrete units). \- **Economic definitions:** Utility functions are specified as a **discriminated union** type – currently supporting **Cobb-Douglas/CES** and **Linear** utility forms (with parameters like rho, wA, wB for CES, or vA, vB for linear marginal utilities). This structured approach means each agent's preferences are encoded in a uniform way (dictionary with type and params), making it easy to extend with new utility types in the future (e.g. Leontief or Stone-Geary preferences could be added without changing the engine logic, just the utility evaluator module). \- **Agent state:** Each agent is represented as a record with fields for id, pos (grid coordinates), inventory (amounts of each good), utility (the utility function spec as above), quotes (the agent's current ask and bid price for trade), vision_radius (how far they can see other agents/resources), and move_budget_per_tick (how far they can move). This explicit schema makes the agent's state at any time fully transparent. Invariants like nonnegative inventories are maintained, and trades are implemented to **conserve total quantities** of goods in the system (goods are neither created nor destroyed by trade, they just move between agents). \- **Environment and resources:** The world is an Environment defined by a grid size and a list of resource cells (each cell has a position, a type of resource good, and an amount). Resources can be consumed by agents (foraging) and they regenerate over time with the cooldown rule. \- **Quotes and trading:** Each agent's bid/ask quotes for trading one good for another are encapsulated in a Quote object with ask_A_in_B and bid_A_in_B (the agent's ask price and bid price for 1 unit of A in terms of B). The engine's **matching and trade logic** uses these quotes to decide who trades with whom and at what price. A deterministic pricing rule is applied when a trade happens (essentially the midpoint between the buyer's bid and seller's ask), and then the engine computes the largest integer quantity ΔA (up to a max limit) that yields a positive utility gain for both sides given that price. This careful algorithm guarantees trades only execute if they strictly improve both agents' utility (ΔU \> 0\) and respects an upper bound on trade size per tick. After a trade, agents update their inventories and immediately refresh their quotes (so they might adjust prices after gaining or losing goods). \- **Scenario configuration:** The simulation scenarios are defined in **human-readable YAML files** with a schema capturing all necessary parameters. A scenario file includes fields such as: number of agents, grid size, initial inventory distributions for each good (could be an exact number or a random distribution spec), utility function mix for the agents (one can specify a mix of types with weights to create heterogeneity), and various global parameters (spread for bid/ask quotes, vision radius, interaction radius which can limit who can trade with whom, movement budget, max trade size ΔA_max, foraging rate, regeneration rate beta, etc.). This schema approach ensures that **experiments are easily repeatable and configurable** – one can tweak a scenario file and know exactly what that implies for the initial state and rules of the simulation. All scenario files and results include a schema_version for compatibility.

Overall, the architecture emphasizes **clarity and determinism** at the engine level, which supports the project's dual aims: \- **Pedagogical Clarity:** The one-step-at-a-time deterministic tick, combined with extensive logging, means that a student or developer can trace through a single tick and understand why each trade or movement happened. Nothing is "random" or black-box – even stochastic elements (if introduced for research) would be done in a controlled, seeded way. This makes the platform ideal for teaching, because an instructor can point to a specific agent's decision and link it back to theory (e.g., "Agent 3 didn't trade because the price didn't exceed its reservation value, as predicted by utility theory" – a claim verifiable by inspecting the logged utilities and quotes). \- **Research Reproducibility and Extensibility:** By enforcing strict determinism and documenting data contracts, the engine lays a foundation that can be trusted for research simulations. Experiments can be run many times, or in large batches, without noise confounding the results (unless intentionally added). Moreover, the clean separation of concerns (utility functions, matching logic, movement, etc.) and the generic type system make it easier to extend the model. For example, adding a new good type "Money" or a new phase for a market mechanism can be done while preserving the existing structure and determinism guarantees, as long as it adheres to the ordered-phase and stable-iteration principles. This careful design echoes the original vision's call for a platform that is both *educational* and *research-grade*, as well as flexible enough to evolve through many modules of economics content.

Finally, the architecture was also influenced by the idea of a **dual-mode interface** (Educational vs. Research modes) from the original plan. In practice, the current implementation uses a single unified mode but is built in a way that different behaviors can be toggled via parameters (for example, one can run a deterministic, fully rational scenario or introduce stochastic decision elements for experimentation). The planning moving forward includes making this dual-mode concept more explicit (e.g., a switch to enforce "perfect rationality" vs "behavioral quirks"). The key is that the underlying engine is capable of both: it can simulate textbook-like rational agents (already does), and it can accommodate more complex behavioral rules since agents' decision logic is modular. As noted in the vision, *rationality can be treated as a tunable parameter* – the architecture is ready to support that by swapping decision algorithms or adding noise, withoutaltering the fundamental simulation loop. This flexibility will allow VMT to serve as an interactive textbook in one mode, and as an experimental economics platform in another, fulfilling the original mission.

## Vision Roadmap

With the core barter economy in place, the long-term vision for VMT is to **expand step-by-step into a comprehensive microeconomic simulation platform**. This roadmap outlines the planned trajectory of features and modules, roughly in the order they would be tackled. It mirrors the progression of topics in a standard microeconomics curriculum and the original VMT vision document, moving from basic individual choice and exchange toward markets, production, and beyond. Each stage of development not only adds new technical capabilities but also opens up new pedagogical and research possibilities (with a conscious eye on supporting both *Educational* and *Research* modes of use).

**Long-Term Trajectory:**

1. **Foraging & Barter Economy (Baseline)** – *Current State.* Start with the simplest exchange environment: agents gather resources (forage for goods A and B) and trade them via **bilateral barter**. This corresponds to a basic **exchange economy** in micro theory (endowment exchange). VMT v1.1 has achieved this stage: agents have well-defined preferences (utility functions) and negotiate trades to mutual benefit, illustrating concepts like *marginal rate of substitution*, *gains from trade*, and *indifference curves*. This stage aligns with **Part I: Individual Decision-Making** in a curriculum, demonstrating utility maximization and exchange in a simple form.

2. **Introduction of Money (Monetary Exchange Economy)** – The next step is to introduce a **medium of exchange** – money – transforming the barter system into one with explicit **budget constraints**. In economic terms, this moves the simulation from a pure exchange economy to a **quasi-market economy** where one good (money) serves as a numeraire. Agents will have an initial endowment of money and prices will be expressed in monetary terms. This stage enables exploration of **consumer choice under a budget constraint**, price systems, and the notion of a *numeraire*. Pedagogically, it lets users see how money facilitates trade (e.g. enabling multi-party exchange via a common currency) and how having a budget changes agent behavior (e.g. saving, budgeting). Research-wise, this paves the way to study emergent monetary phenomena (inflation, liquidity, etc.) once markets are in place. **Educational Mode:** money can initially be treated in a simple way (e.g. adding a constant marginal utility for money so agents always value having more money), which replicates the textbook device of quasilinear utility. **Research Mode:** later, money's value can be made emergent (agents form expectations of future purchase power) to study more realistic monetary dynamics. This stage corresponds to parts of **Consumer Theory and Exchange** (one could illustrate budget lines and Walrasian equilibrium in a simple exchange economy with money).

3. **Local Market Mechanisms (Many-to-Many Trade)** – With money in place, the simulation can graduate from bilateral trades to a more **market-like mechanism**. Instead of matching agents strictly pairwise, we can simulate a **posted-price market** or a simple auction within groups of agents. Practically, this means if several agents are in trading range, they could collectively determine a market price for a good in a given tick (e.g. the lowest ask and highest bid that meet will set a price, and multiple buyers and sellers trade at that price). Implementing a market mechanism introduces concepts of *supply and demand*, *price formation*, and *market equilibrium* in a localized setting. In educational terms, this is a huge step: students can see a microcosm of a market – the "invisible hand" at work – as an emergent outcome of agent interactions. Instead of manually pairing agents, the system begins to show how prices adjust to clear markets (at least within a small group). This corresponds to **Part III: Market Equilibrium (Partial Equilibrium)** in the curriculum, illustrating how a market demand-supply equilibrium price might emerge. For research, this feature moves the platform into a new category, enabling analysis of market efficiency, price volatility, and comparisons of different market mechanisms (posted prices, double auctions, etc. could be experimented with in simulations). We plan to start with a **posted-price mechanism** (deterministic, easier to implement) and later may experiment with a **discrete double auction** mechanism for richer market dynamics. Ensuring determinism in a market setting is critical – the design will fix an order for processing the order book and executing trades to keep results reproducible.

4. **Production Economy (Firms and Factor Markets)** – After establishing exchange and consumption, the next layer is to add **production**. This means introducing *firm agents* that produce goods using inputs (like labor or raw materials) according to production functions, and *consumer agents* who also may supply labor or other factors. This stage transforms VMT from a pure exchange economy into a **production economy** (moving into **Part II: Production and Supply** in a typical curriculum). New elements would include **production functions** (e.g. Cobb-Douglas production for firms), profit maximization behavior (firms decide how much to produce to maximize profit given prices), and possibly a labor market (where agents "work" for wages to earn income). Pedagogically, this enables demonstration of supply curves, cost structures, and the interaction of factor markets with product markets. One could simulate, for instance, a simple agricultural economy where agents allocate labor to produce good A and trade with others for good B. It also sets the stage for showing concepts like *partial equilibrium* in a market with supply and demand (one could observe how an output market reaches equilibrium given producers and consumers, or how a negative shock to supply affects price). This maps to topics in **producer theory, market structures (perfect competition assumption initially)**, etc. In research terms, adding production vastly enriches the possible scenarios – we could examine outcomes under different market structures (perfect competition vs. monopoly if we allow one firm, etc.) and study efficiency or agent-based industrial organization.

5. **General Equilibrium & Welfare** – With multiple goods, money, and production all in play, the platform can attempt to simulate a **General Equilibrium (GE)** scenario. This stage corresponds to the culmination of a microeconomics course: **Part IV: General Equilibrium and Welfare Economics**. The idea is to allow all markets (goods and possibly factor markets) to clear simultaneously through a price adjustment process. In traditional theory this is handled by a fictitious Walrasian auctioneer. In VMT, we can approximate this via iterative tatonnement or by actual agent behavior adjusting prices. Achieving general equilibrium in an agent-based model is challenging, but even a simplified multi-market simulation where prices adjust gradually to clear excess demand would be a powerful demonstration of Arrow-Debreu theory. The platform could show the path to equilibrium as a dynamic process, or illustrate cases where equilibrium doesn't hold (market failures, multiple equilibria, etc.). Welfare analysis tools could be introduced to measure Pareto efficiency or surplus distribution in the simulation. For educational mode, one might configure highly rational agents in a simple economy to observe them converging to the predicted general equilibrium (thereby validating the theory). In research mode, one could relax assumptions and explore how robust or fragile equilibria are under more realistic behavior. This stage completes the core microeconomic curriculum vision for VMT – at this point, all the major elements of microeconomic theory (consumer, producer, markets, money, equilibrium) are represented in some form.

6. **Information Economics & Mechanism Design** – The final frontier in the roadmap involves advanced topics like **asymmetric information, strategic behavior, and mechanism design** (broadly aligning with **Part V: Information and Mechanism Design** in textbooks). This includes modules for scenarios like adverse selection (e.g., a Lemons Market simulation where buyers cannot observe quality), moral hazard (principal-agent problems), auctions of various formats (first-price, second-price auctions where agents strategize their bids), voting and social choice simulations, and other designed mechanisms to achieve certain outcomes. It also encompasses explicit **game theory** modules (beyond the implicit negotiation so far) – e.g., adding a mode for agents to play matrix games or repeated games on the grid to demonstrate Nash equilibria or cooperation dynamics. These features would transform VMT into a platform not just for competitive markets but also for strategic interaction scenarios and the study of how information affects outcomes. Pedagogically, these are more specialized, but extremely interesting: students could, for instance, witness how an auction outcome changes based on auction rules, or how an insurance market fails under adverse selection. In research mode, one could implement custom mechanisms and test their efficiency or agents' strategic behavior in complex settings. This stage is more open-ended and would likely be tackled once the core market economy features are solid. It's worth noting that even if these are far-off features, the earlier design choices (determinism, modular utilities, flexible agent rules) will make implementing them easier when the time comes.

**Educational vs. Research Modes:** Across all these roadmap stages, a guiding principle is to maintain a clear separation (or toggle) between an **Educational Mode** and a **Research Mode** of using VMT. In educational mode, the aim is to demonstrate canonical theory in the clearest way – this often means using simplified, rational-agent models (e.g. quasilinear utility for money, symmetric information, equilibrium-seeking behavior) so that the simulation outcomes match what standard theory would predict, thereby validating and visualizing the textbook concepts. In research mode, the platform can relax these assumptions: one might introduce bounded rationality (agents use heuristics or have limited foresight), heterogeneous expectations, or random shocks. The original vision explicitly calls for this dual capability – *"agents can be flawless optimizers \[for education\] or have cognitive limitations and stochasticity \[for research\]*". The roadmap above is designed to serve both uses. For each new feature, we will consider: *What does this enable us to teach or illustrate?* and *What research questions could this model help explore?* For example, adding money allows teaching the concept of fiat currency and budgets, while in research it allows exploring how money might gain value or how monetary policy (if one added a central bank agent) could ripple through an economy. Adding market mechanisms teaches supply and demand equilibrium, while also enabling research into market microstructure or price dynamics under different rules. In practice, the **implementation will include toggles or parameters** to switch between modes where appropriate (for instance, a parameter to add random "mistakes" in agent decisions for research experiments, turned off for deterministic classroom demos). This way, the same platform can seamlessly shift from illustrating textbook diagrams to running novel economic experiments, fulfilling the vision of VMT as both a teaching **and** research laboratory.

## Immediate Roadmap (Next 1–3 Months)

To progress toward the long-term vision, the next few months of development will focus on a series of **incremental milestones**. Each milestone adds a layer of functionality or polish, building on the solid core while keeping the system deterministic and robust. The focus is on features that provide high conceptual value with manageable implementation risk, as identified in recent strategic reviews. Below is the immediate roadmap with key objectives:

1. **Polish the Core (v1.1 Finish Line):** Before adding new features, it's critical to solidify and document the existing engine. The aim is to make v1.1 (forage + barter) a clean, well-understood base:

2. *Documentation:* Write a concise **engine overview** that clearly explains the 7-phase tick cycle and how the different systems (perception, decision, matching, etc.) interact each tick. This could be a README.md within the engine module. It will serve as a quick-reference for the developer and new contributors, summarizing what happens in each phase and how data flows between systems.

3. *Code Clarity:* Review and annotate complex parts of the code (especially the trading logic in matching.py and quotes.py, and the utility calculation in econ/utility.py). Add comments that explain the reasoning behind key design choices – for example, why we break ties by lower agent ID (to maintain determinism), or how the price search algorithm works. This will make the code more maintainable and easier to revisit after a break.

4. *Foundational Scenario:* Create a **canonical example scenario** (e.g., scenarios/foundational_barter_demo.yaml) that showcases the core barter setup. This scenario should be heavily commented with explanations for each parameter, effectively serving as a tutorial. By reading and running this scenario, one should learn how to configure a basic exchange economy in VMT. This is a form of documentation that lives close to the code, demonstrating correct usage and expected outcomes.

5. *Integration Test:* Add a long-form integration test (e.g., test_foundational_scenario.py) that runs the above scenario for a certain number of ticks with a fixed random seed and then verifies the final state. For instance, the test can assert that total goods remained constant (no creation/destruction), or that certain trades happened given the scenario setup. This "end-to-end" test will act as a guard against regressions: as new features come in, running this test will ensure the core barter behavior remains consistent and no unintended side effects have broken the baseline.

6. *Minor Fixes & Updates:* As part of polish, tie up any loose ends (if any tests are marked TODO or skipped, address them, ensure variable names and formatting are clean, etc.). The idea is that by the end of this polish, the v1.1 engine is a stable springboard for new features, with zero uncertainty about its correctness or clarity.

7. **Add Mode Toggles (Foraging/Trading Cycles) – v1.2:** Implement a feature to **toggle game modes between "forage-only" and "trade-only"** in a simulation, according to a global schedule. The concept is to alternate phases of pure accumulation with phases of pure exchange. This will introduce an *implicit budget constraint*: during trading periods, agents cannot forage new goods, so they have to budget what they gathered during foraging periods. Concretely:

8. Add a new scenario parameter (e.g., mode_schedule) that defines the cycle (for example, X ticks of foraging then Y ticks of trading, repeat). If not specified, the default behavior is the current one (both foraging and trading happen each tick, i.e. no enforced mode).

9. Modify the engine loop to respect the mode: in "forage-only" ticks, **skip trading/matching phases** entirely; in "trade-only" ticks, skip the foraging action phase. Movement and perception can occur in both as normal (agents can reposition during either phase unless we later add a toggle for movement too).

10. Ensure determinism of the mode schedule – e.g., the mode could be a function of the tick number (using the schedule parameters) so that all runs agree exactly on which ticks are trade vs forage.

11. This feature is relatively contained (does not upheave existing logic, just conditionally bypasses actions) and **high-reward educationally**: it allows the simulation to demonstrate how agents accumulate goods and then trade them, mimicking a two-stage consumption decision (earn income then spend it). It effectively creates a dynamic where agents experience a "budget" of goods in the trade phase – a stepping stone to introducing money explicitly.

12. We will add tests to verify that when mode schedule is on, agents truly do not trade during forage-only ticks and do not forage during trade-only ticks. Also test that the mode switching happens exactly on schedule.

13. Telemetry: log the mode changes for analysis (e.g., a log entry when the mode flips, and perhaps include the current mode in each agent decision log).

14. Deliverable: a demo scenario (say, scenarios/mode_cycle_demo.yaml) with a short cycle (e.g., 5 ticks forage, 5 ticks trade) to illustrate how agents' inventories grow during foraging and then get exchanged in trading bursts. This scenario can be used to visually confirm the intended emergent budget-constraint effect.

15. **Introduce Money (Quasilinear Utility Model) – v1.3:** Implement a basic form of **money** in the simulation. This is a pivotal addition: it will enable explicit budget constraints and more complex trading patterns (multi-good exchange mediated by money). However, it must be done in a way that respects the engine's constraints:

16. **Option A – Quasilinear Money:** The near-term plan (v1.x) is to treat money as a third good "M" that agents can hold, with a constant marginal utility. In practice, we will extend the utility specification to allow a term like + λ \* M added to an agent's utility function (where λ is a parameter representing the utility of one unit of money). This means an agent's total utility is $U(A, B) + \\lambda M$. Money thus directly increases utility at a constant rate (no diminishing returns to money in this simplistic model). We can allow λ to be specified per scenario or per agent (for now likely a global λ).

17. This approach is **straightforward to implement** in the existing engine: we simply include money in the inventory, and when computing utility or utility changes, include the $λ \\Delta M$ term. The trading logic (quotes and matching) can treat money as just another good – with the important difference that money is not foraged from the environment (no resource spawns for M). Agents will post bids/asks for exchanges involving money using the same reservation price logic (their reservation price for money in terms of a good comes from the marginal utility ratio with λ). Because money is an integer unit (cents perhaps), all our rounding and ΔU \> 0 checks still apply cleanly. We will ensure that trading A ↔ M or B ↔ M uses the same price search and trade execution algorithm as barter trades, thus fully preserving determinism and the one-trade-per-tick rule.

18. By adopting quasilinear utility for now, we **avoid needing a special case** for money's utility – it's just another term in the utility function. However, as noted in the strategy discussions, quasilinear utility "bakes in" a certain value of money (λ) rather than letting it emerge. This is acceptable in Educational Mode (it mimics how textbooks introduce money as giving a constant utility per dollar), but we acknowledge that in the future we want to move to *Option B*: an **instrumental value** model where money has no intrinsic utility but agents value it for the opportunities it provides (essentially computing a shadow price of money each tick based on available trades). Our plan is to implement Option A first (which is recommended as the v1 approach) and later possibly upgrade to the more sophisticated Option B. Importantly, the Option A implementation will be done in such a way that it doesn't preclude Option B – for instance, we could structure the code so that if λ is set to a special value (or via a different utility type), we could switch to a dynamic calculation of money's utility (λ_hat) in future without rewriting the trade engine.

19. Implementation steps: update the scenario schema to allow an initial money endowment for agents (e.g., initial_inventories: {M: 100}). Possibly add a new utility type or a parameter to existing utility to include λ. Update the utility calculation functions to handle money. Update quote generation to include cross-good quotes involving money (e.g., an agent will have quotes for exchanging A for M and B for M if they have a positive endowment or need for money). Most of the heavy lifting in matching/trade can remain the same since the formulas already consider two goods at a time – we're just adding more possible pairings (A–B, A–M, B–M trades).

20. We will write tests to ensure that money trades obey the intended rules: for example, *increasing an agent's money by 1 should raise utility by exactly λ* (so the ΔU checks work as expected); an agent with only money and no goods will not be able to increase utility except by buying goods; and edge cases like an agent with zero goods and some money perceiving no available goods should yield λ_hat = 0 (no value for money if nothing to buy – relevant when we later implement Option B logic). Also test that the conservation of money holds (money just changes hands, not created or destroyed, except possibly via an external "bank" in scenarios if we allow money injections, which we don't plan for now).

21. Telemetry: augment the logging to track money usage. For instance, mark trades that involve money (we might add a boolean field or a separate "money trades" log). This will help analyze how money circulates (e.g., velocity of money in the simulation). The GUI might also need a small update to display money holdings of agents and perhaps to treat good "M" specially (like not showing it on the map, but maybe in a ledger).

22. Deliverable: a scenario like scenarios/money_quasilinear_demo.yaml to demonstrate a simple economy with money. For example, two goods A and B with one agent starting with all A, another with all B, and a third agent with money – see how money flows as the medium for A-B exchange. This scenario can illustrate that agents willingly trade goods for money and then money for other goods, confirming that money is effectively facilitating indirect exchange.

23. **Prototype Posted-Price Market – v1.4:** Once money is in place, the next feature is to implement a **posted-price market mechanism** for trading, as an alternative to strict bilateral matching. This represents the shift toward many-to-many trade within the simulation. The plan is to start with a simple, deterministic market per connected group of agents:

24. **Connected Component as Market:** In each tick's Perception phase, determine the groups of agents that are within interaction range of each other (i.e. form a network of possible trade relations). Each such group could be considered a "market" for that tick. If a market (group) has only 2 agents, that's just a bilateral trade as usual. If it has more, we invoke a market-clearing mechanism.

25. **Price Determination:** For each market group, aggregate the agents' quotes to decide on a single **market price** for each good (or specifically for one good vs money). For the prototype, we can implement a **posted-price for one good at a time** (e.g., market for good A in terms of money, then similarly for B). One simple rule: find the lowest ask price among sellers and the highest bid price among buyers; if the highest bid ≥ lowest ask, a trade can happen. We can set the market price to something like the midpoint of that bid and ask (or possibly just the ask or bid if we want a deterministic bias). Another approach is an order-book style: sort all asks and bids and find an equilibrium price where supply meets demand – but given our discrete small numbers, a simpler rule is fine. The key is it must be deterministic (tie-break any equal bids or asks by agent ID or fixed rule).

26. **Matching at Market Price:** Once a price is set, allow multiple agents to trade at that price in that tick. For example, all sellers who were willing to sell at or below that price and all buyers willing to buy at or above that price can execute trades. However, to maintain the one-trade-per-agent constraint, each agent should only complete at most one trade in the market. We can match buyers and sellers in ascending order of their IDs to decide who trades first, executing one trade lot at a time. Continue matching until no more mutually beneficial trades remain or all agents have traded once. Because all trades in that tick use the same price, this mimics a single-price market clearing.

27. **Determinism and Constraints:** We will ensure the above mechanism is carefully deterministic. The component grouping will always yield the same groups given the same positions. The price rule will be deterministic given the set of quotes (e.g., consistent tie-break rules). The matching uses sorted queues of buyers and sellers. And importantly, we still enforce ΔU \> 0 for each trade – if the market price is such that some potential trade between a specific buyer and seller wouldn't be utility-improving, that trade simply won't execute (or that agent opts out). This ensures we don't violate individual rationality. Essentially, the market mechanism is a layer on top of the bilateral logic: it finds a price and then allows trades that satisfy the usual conditions at that price. We will also set a threshold: if a group is below a certain size (say \<3 agents), we might just skip the market mechanism and default to bilateral to avoid unnecessary overhead.

28. The educational value of this feature is significant: it begins to demonstrate how a *market-clearing price* can emerge from decentralized quotes, visualizing the concept of an equilibrium price in a small market. Rather than pairs trading at possibly different negotiated prices, everyone in the group faces the same price – akin to a mini Walrasian auction. Students can see concepts like supply/demand curves play out (we could plot the asks and bids to show how the crossing point determines price). For research, this opens the door to studying market efficiency and dynamics in agent-based models. We could compare the outcomes under this posted-price mechanism to the theoretical equilibrium or to other mechanisms.

29. Implementation steps: This will involve changes mainly to the matching/trade system. We might create a new system or mode for market trading. When enabled (perhaps via a scenario flag or automatically if money is present and group size threshold met), the engine would, in the Trade phase, execute the market algorithm for that component instead of pairwise matching. We'll have to carefully update how quotes are used – possibly consider only money trades in markets (so markets are for goods in exchange for money, which is simplest). If agents can trade goods for goods in a market context, that becomes a double auction for two goods – more complex. It might be pragmatic to say: once money exists, markets will be defined for trading goods against money (money being the universal medium). That means essentially we are creating partial equilibrium markets for each good's price in money. This aligns with standard economics where each good has a price in currency. So, there'd be a market for A (price in $) and a market for B (price in $) each tick, for each region. This approach is easier to manage and explain.

30. We will of course add tests: e.g., a test where a component of 3 agents with certain endowments and utility values yields a deterministic single price and expected trades (and that the results match running the bilateral trades sequentially in some cases, or at least that utility is non-decreasing for all). We will test that the market mechanism produces the same outcome every time for a given scenario (no randomness creeping in).

31. Logging: extend telemetry to record market events – for each market (component) per tick, log the price and any trades that occurred. This will allow analysis like plotting price over time in a scenario to see if it converges.

32. Deliverable: possibly adapt one of the existing scenarios or create a new one to demonstrate the market. For instance, a scenario with a cluster of 4–5 agents all within trading range and see how they establish a common price for trades, as opposed to pairwise differing prices. This could be part of a tutorial on supply and demand.

33. **Telemetry & Testing Enhancements:** Alongside the above feature milestones, we will continuously maintain and improve **testing and telemetry**:

34. **Test Coverage:** Each new feature will be accompanied by focused unit tests to verify its correctness under edge cases. For example, tests for mode toggles will ensure that no trades occur during forage-only ticks and vice versa. Tests for money will check that an agent's utility accounting with money is correct and that trades involving money conserve utility improvements and quantities. Tests for the market mechanism will validate price determination and matching outcomes. Additionally, after each feature, the full existing test suite will be re-run to ensure **no regressions** occur in the previously working functionality (e.g., the introduction of money or markets should not break the determinism of barter trades, etc.). Having the earlier-mentioned integration test on the foundational scenario is particularly useful here – it will catch if any new feature unexpectedly alters the core behavior.

35. **Telemetry Updates:** We will extend the logging/telemetry schema to capture new dimensions of the simulation's state introduced by each feature. Specifically:

    * Log **mode changes** in a mode_changes log or similar, with the tick number and new mode. Also include the current mode in other logs (like decisions) so that offline analysis can easily separate what happens during foraging vs trading periods.

    * Expand the **trade log** to indicate trades that involve money (e.g., add a field is_money_trade or list the goods traded, such that one can filter trades where money was one side). This will help in tracking money flow through the system – an important metric in monetary economics.

    * Introduce a **market events log** when the market mechanism is active: for each market component in each tick, record the determined price, number of trades executed, etc., and maybe the list of agents involved. This allows visualization of price convergence, market liquidity, etc.

    * The GUI log viewer and any analysis scripts will be updated accordingly to handle these new logs or fields. We'll ensure that these additional logs do not bloat the output unnecessarily – likely they will be off by default unless the feature is used (no mode_changes log if mode scheduling is off, etc.). The existing SQLite logging system can be extended with new tables in a backwards-compatible way.

36. **Performance and Refactoring:** As features are added, we will keep an eye on performance. The current engine runs efficiently for a moderate number of agents; features like market matching might introduce higher complexity (e.g., grouping and sorting orders). We will do basic performance tests to ensure the simulation remains snappy for typical educational scenarios (perhaps up to tens of agents). If needed, small optimizations or the option to turn off certain logs (to speed up runs) will be considered. However, given the small scale of most planned scenarios (classroom demos, etc.), clarity and determinism will be prioritized over micro-optimizations.

37. The testing and telemetry improvements ensure that as we add complexity, the system remains **transparent and reliable**. This reinforces the project's ethos: every new piece of functionality comes with the means to verify and observe it in action. By the end of 3 months, after implementing mode toggles, money, and the market prototype (plus polish), we aim to have not just new features, but also the tools to demonstrate and test those features thoroughly.

## Planning System Specification

This planning document is intended to be a **living design and planning guide**. Now that it has been created as "v2" of the planning docs, it will serve as the authoritative roadmap for development going forward. Here we outline how this document will be used and maintained within the project:

* **Location & Structure:** The document will be saved in the repository (proposed path: PLANS/Planning-Post-v2.md), replacing the previous Planning-Post-v1.md. It is structured with clear sections (purpose, current state, architecture, roadmap, etc.) so that both high-level vision and low-level action items are easily accessible. The top of the document (Purpose and Current State) provides context and vision, while later sections delve into concrete plans and checklists. This structure is meant to make it easy to **update individual sections** as needed without rewriting the whole document – for example, the "Immediate Roadmap" can be revised in the future to add new tasks or mark tasks as completed.

* **Iterative Updates (v2.1, v2.2, ...):** Future planning revisions will be **integrated into this same document** to keep a single source-of-truth. Minor updates (tweaks to plans, re-prioritization, adding a new short-term task) may be made by directly editing the relevant section (with perhaps a mention of the date/revision). More significant shifts in strategy can be recorded by appending a new subsection or an appendix describing the changes. For example, if after completing v1.4 we decide on the next set of features, we might add an "Immediate Roadmap – Next Steps (v2.2)" section. Alternatively, a simple changelog at the end can list revisions (e.g., "**v2.1** – Added details on multi-good extension. **v2.2** – Updated testing strategy."). The idea is to **avoid scattering multiple planning files**; instead, maintain this one as an evolving document (up until perhaps a major version change like v3 when the project reaches an entirely new stage, at which point a new document might be warranted).

* **Versioning and Navigation:** The document itself will indicate its version (v2.0 initially) and date, and will be updated to v2.1, v2.2, etc., as changes are made. We will ensure that the repository's documentation index or README clearly points to this planning doc for anyone looking for the project's direction. The planning doc will also cross-reference other key documents and resources: for example, it can link to the Retrospective_Overview.md for historical context, to design notes like typing_overview.md for detailed architecture definitions, and to scenario files for specific examples. By interlinking in this way, we create a network of documentation: the planning doc as the high-level map, with references into more detailed docs for specifics. Each time a new scenario or design doc is added that is relevant, we can update the planning doc to include a reference or discussion of it.

* **Living Document Practices:** As a living document, this file should be updated in sync with development. We will adopt the practice of updating the plan whenever a milestone is completed or when priorities change. This might mean writing a brief **post-mortem note** in the current state or roadmap after finishing a feature (e.g., "Mode toggles (v1.2) completed – result and observations..."). However, to keep the document concise, we might instead update the wording of the plan to reflect completion (for instance, moving a feature from future tense to past tense and noting it's done, and then adding the next to-do). The checklists at the end (see below) provide a simple way to mark off completed tasks.

* **Reference and Alignment:** This document will also serve as the alignment tool to ensure that any new contributors or stakeholders can quickly grasp what the project is about and where it is heading. It starts with the core philosophy and runs through to specific tasks, embodying the principle that *every short-term task fits into a long-term vision*. By maintaining this alignment, we reduce the risk of feature creep or detours that don't contribute to the overall goals. It's essentially the narrative that connects code-level issues with textbook-level aspirations – something especially important for a solo developer to stay motivated and on track.

* **Linking with Code and Scenarios:** We plan to locate this document in the PLANS/ directory as noted, and ensure it is easy to find. The scenario files created as part of the roadmap (like the foundational demo, mode demo, etc.) will be referenced in the text, and those scenario files will in turn have comments referencing this planning doc (closing the loop: e.g., a YAML scenario might say "This scenario corresponds to the foundational barter demo described in Planning-Post-v2.md"). Likewise, if we have code that specifically implements a planned feature, we might reference the plan in code comments (for instance, in the code handling mode scheduling, a comment might cite the plan section for mode toggles). These practices ensure traceability from high-level design to implementation.

* **Tooling for Planning:** The checklists in the next section are written in Markdown within this document so that they can be easily viewed and even edited. While Git itself will serve as the version control for updating the plan, we may consider using GitHub issues or project boards referencing the tasks enumerated here for day-to-day tracking. However, the authoritative description of each task and its context will remain in this document, whereas issues could be pointers or smaller subtasks derived from it.

* **Future Planning Documents:** Looking further ahead, if the project undergoes a major overhaul or completes the current roadmap entirely, we might then start a Planning-Post-v3.md for the next epoch of development. But until then, v2 will be appended and refined. This avoids confusion of multiple overlapping plan files (which happened to some degree with v1 docs and various brainstorming files).

In summary, *Planning-Post-v2.md* is now the single comprehensive plan: it will be kept up-to-date, it resides in the repository for all to see, and it will guide the project's journey from the current state towards the envisioned microeconomic laboratory, one iteration at a time.

## Checklists and Deliverables

To translate the roadmap into action, below are **checklists of tasks** for each near-term milestone. These can be used to track progress. (Each item is written as a Markdown task that can be checked off in the rendered view.)

### v1.1 – Core Polishing and Documentation

* \[ \] **Engine documentation:** Write a vmt_engine/README.md explaining the 7-phase tick cycle and each system's role. Include a diagram or bullet flow of Perception → ... → Housekeeping.

* \[ \] **Code commenting:** Review matching.py, quotes.py, econ/utility.py and other complex modules. Add comments explaining non-obvious logic (e.g. tie-break by ID for determinism) and the reasoning behind the price search algorithm and cooldown mechanism.

* \[ \] **Foundational scenario:** Create scenarios/foundational_barter_demo.yaml showcasing a simple barter economy with thorough inline comments. Ensure it covers typical parameters (vision_radius, spread, etc.) with explanations.

* \[ \] **Integration test:** Implement tests/test_foundational_barter_scenario.py that runs the above scenario for a fixed small number of ticks and asserts the final inventories and log outputs match expected results (e.g., a specific trade happened, total goods conserved, etc.).

* \[ \] **Misc polish:** Clean up any TODOs, ensure all 54+ tests pass, update README or documentation index to point to Planning-Post-v2, and remove deprecated Planning-Post-v1.md references.

### v1.2 – Mode Toggles (Foraging vs. Trading Phases)

* \[ \] **Scenario schema:** Add mode_schedule configuration in scenario params, including sub-fields (type of schedule, lengths of forage/trade windows, starting mode).

* \[ \] **Engine logic:** Implement global mode switching based on mode_schedule. On each tick, determine the current mode (forage or trade) and **skip trade matching in forage-only mode**; skip foraging actions in trade-only mode. Ensure movement and perception still occur in both by default.

* \[ \] **Enforcement:** In trade-only mode, prevent any resource harvesting; in forage-only mode, prevent any trades from executing. Verify that cooldowns are handled gracefully (e.g., trade cooldowns don't trigger during forage mode because no trade was attempted).

* \[ \] **Deterministic schedule:** Use tick counter to alternate modes with exact periodicity (no drift). E.g., if forage_ticks=5, trade_ticks=5, then ticks 0–4 forage, 5–9 trade, 10–14 forage, etc. Document this formula.

* \[ \] **Testing:** Add test_mode_schedule_cycle.py to ensure that during a global_cycle schedule, agents never trade in forage windows and never forage in trade windows. Test that mode flips exactly on the boundary ticks and that all agents experience the same mode simultaneously.

* \[ \] **Telemetry:** Log mode changes. Create a mode_changes table with entries for each tick a mode switch occurs (fields: tick, new_mode). Also, add current mode as a field in decision logs for easier analysis.

* \[ \] **Demo scenario:** Provide scenarios/mode_cycle_demo.yaml with a short cycle (e.g., 3 ticks forage, 3 ticks trade) and a couple of agents, to illustrate inventory accumulation vs. trade alternation. Include expected outcome comments (e.g., "Agent 1 accumulates resources in forage phase, then trades them in trade phase for Agent 2's resources, demonstrating budget constraint.").

### v1.3 – Introducing Money (Quasilinear Utility)

* \[ \] **Schema updates:** Extend goods definition to include a money good "M". Allow initial money in inventories (e.g., initial_inventories: {M: 100}) and possibly a global lambda_money parameter for utility.

* \[ \] **Utility function:** Implement quasilinear utility addition: for any utility function $U(A,B)$, the total utility becomes $U(A,B) + \\lambda \\times M$. This could be done via a wrapper or by internally adding a linear term. Ensure $\\lambda$ is configurable (default 1 for convenience or set in scenario).

* \[ \] **Engine integration:** Treat money as another good in all relevant places. Update reservation price calculations to handle trades involving M (e.g., an agent with utility $U(A,B)+\\lambda M$ has a reservation price for selling 1 unit of A for money based on $\\Delta U = \\lambda \\Delta M$ vs. loss of utility from A) – effectively, reservation price for A in money = MU(A) / λ. Ensure quote generation uses this. The trade matching algorithm can remain unchanged since it will consider any good pairs, including (A,M) and (B,M).

* \[ \] **Foraging and Money:** By design, money is not foraged. Confirm that resource generation does not create money. Money enters the system only via initial endowments (in scenarios) or through trades (conserved between agents).

* \[ \] **Testing:** Create test_money_quasilinear.py:

* Verify that gaining money increases utility by exactly λ (e.g., an agent trading goods for 5 money gets utility increase = 5λ).

* Verify that an agent will trade goods for money if and only if it improves their utility accounting for λ (no trade if λ is too low, etc.).

* Test edge case: if λ = 0 (money gives no utility), agents should never trade goods for money (money would be worthless, a nice check).

* Ensure determinism: trades involving money follow the same rounding rules and one-trade-per-tick constraint.

* Re-run zero-inventory tests with money present to ensure the epsilon guard still works when a good is zero but money is offered.

* \[ \] **Logging:** In the trade log, flag trades that involve money. For instance, add field payout_money or a boolean money_trade to indicate one side was money. Alternatively, have separate log of money transactions. Also log each agent's money holding in the end-of-tick summary if available (to track distribution).

* \[ \] **Demo scenario:** Add scenarios/money_quasilinear_demo.yaml where, for example, two agents trade via money. One agent starts with only good A, another with only money M, and a third with only good B. The expected outcome: agent with money buys A from first agent and B from third agent, facilitating an indirect exchange A \<-\> B through money. Document in scenario how λ was chosen and what we expect to see.

* \[ \] *(Optional:* If time permits, experiment with computing shadow price λ_hat (Option B) in a prototype function, but keep it disabled or as a note for future. We will revisit this in a later version.)

### v1.4 – Posted-Price Market Mechanism

* \[ \] **Component detection:** Implement function to find connected components of agents based on interaction radius each tick (e.g., flood-fill or union-find using agent graph). Assign a unique market ID for each component (deterministically, perhaps the lowest agent ID in the component).

* \[ \] **Market toggle:** Decide threshold to activate market mechanism. If a component's size ≥ *N* (e.g., 3 or more agents) and scenario has markets enabled, use market trading for that group; if smaller, use existing bilateral trades. Make threshold configurable (market_min_size).

* \[ \] **Price calculation:** For each market component, aggregate quotes of agents for a given good (likely focus on one good vs money at a time). Compute a single market price. Simple rule: find lowest ask ≤ highest bid; if exists, set price = e.g. midpoint (or that ask or bid). Ensure tie-breaks for equal asks/bids are deterministic (e.g., by agent ID or order of processing).

* \[ \] **Market matching:** At the chosen price, create sorted lists of willing sellers and buyers:

* Sellers: those who asked ≤ price (they are happy to sell at that price).

* Buyers: those who bid ≥ price (happy to buy at that price).

* Sort sellers by ascending ID, buyers by ascending ID (to fix order).

* Iteratively match one seller to one buyer in that order, executing one trade lot for each (use the same ΔA determination logic as bilateral, but now ΔB = price * ΔA, round as usual).

* Ensure each agent trades at most once per tick. If one side exhausts (no more sellers or buyers), or all agents have traded, stop.

* If no ask ≤ bid (market price can't be set), then no trades occur in that component (all quotes too far apart).

* \[ \] **Utility check:** Even though price is set, double-check that each matched trade yields ΔU \> 0 for both sides (it should by construction if price is between their reservation values). If any edge case where it doesn't (due to discrete rounding), skip that trade.

* \[ \] **Fallback & compatibility:** Agents still update inventories and refresh quotes after their trade (as in bilateral). But since we only allow one trade per agent, that's end of tick. At next tick, the process repeats – which could yield price adjustments if quotes change.

* \[ \] **Testing:** Create test_market_posted_price.py:

* Case where 3 agents form a market: e.g., one seller with low ask, two buyers, ensure the lowest ask & highest bid define price and the correct buyer-seller pair trades, and the third agent either also trades (if still possible) or waits if only one match per tick.

* Test determinism: ensure that regardless of insertion order of agents, the same price and matches result (this is crucial; we can simulate shuffling the order of agents in a component and confirm outcome unchanged).

* Test threshold: if market_min_size = 4 and only 3 agents in component, verify it falls back to bilateral trades (possibly no trade if not pairwise compatible).

* Ensure that bilateral trade logic still works outside market components and that combining both doesn't cause any interference (e.g., two isolated pairs trade normally while a larger group uses market in the same tick).

* Perhaps test an extreme: all agents in one market – everyone's quotes should yield a single price and multiple trades; compare that outcome to if they had traded bilaterally in some sequence (market should not violate anyone's constraints).

* \[ \] **Telemetry:** Add a market_events log. For each tick and each market that executed, log: market_id, price, quantity traded (or trades executed), list of agent IDs involved, etc.. This can be one entry aggregating the tick's market activity. Also consider logging cases of no trade due to no price overlap (to analyze market failure scenarios).

* \[ \] **Visualization:** Although not immediate, note in documentation how one might visualize market supply & demand from agent quotes. Possibly output the aggregate supply/demand curve for debugging or future UI.

* \[ \] **Demo scenario:** Construct a scenario scenarios/posted_price_market_demo.yaml where, say, 5 agents are in one cluster and have different endowments and utilities. The expectation: they will all trade at a single price each tick. Run it for several ticks to see price stabilization. Include commentary in the scenario file about initial quotes and predicted equilibrium price (if any).

* \[ \] **Extend to multiple goods (future):** Document that this prototype handles one market at a time (likely one good vs money). In future, multi-good markets or general equilibrium tatonnement could build on this.

*(After completing v1.4, the core exchange economy will have been augmented with money and a market mechanism. The next steps might involve multi-good extensions, production, or other features as per the long-term roadmap. Those will be planned in a subsequent revision of this document, incorporating lessons learned from these implementations.)*

Each checklist above is intended to be updated as tasks are finished (e.g., by ticking off checkboxes in the Markdown). This provides a quick visual progress tracker. By following these checklists, we ensure that nothing important is overlooked in development and that each feature is delivered with the necessary support (documentation, tests, etc.). The tasks are derived from the strategic planning discussions and should collectively achieve the immediate goals of the project while keeping it aligned with the grand vision of VMT as a flexible microeconomic simulation lab.