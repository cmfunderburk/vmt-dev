---
globs: src/scenarios/*.py,scenarios/*.yaml,src/telemetry/*.py
description: Guidelines for scenarios (YAML configs) and telemetry (SQLite logging)
---
## Scenarios & Telemetry Guidelines

### Scenario Files (YAML)

Scenarios are in [scenarios/](mdc:scenarios/) directory and define simulation parameters.

#### Schema Reference

**Dataclass schema**: [src/scenarios/schema.py](mdc:src/scenarios/schema.py)  
**Loader**: [src/scenarios/loader.py](mdc:src/scenarios/loader.py)

#### Key Sections

```yaml
grid:
  size: 20                    # NxN grid (integer)
  
agents:
  count: 3                    # Number of agents
  initial_position: "random"  # or "center" or explicit list
  initial_inventory:
    A: 10                     # Integer inventory
    B: 10                     # Integer inventory

utilities:
  mix:
    - type: "ces"             # or "linear"
      weight: 0.8             # Probability weight (must sum to 1.0)
      params:
        alpha: 0.5            # CES: share parameter
        rho: 0.5              # CES: substitution parameter
    - type: "linear"
      weight: 0.2
      params:
        alpha: 0.6

params:
  # Economic
  spread: 0.05                # Quote spread (float)
  dA_max: 5                   # Max trade quantity (integer)
  epsilon: 0.001              # Zero-inventory guard (float)
  
  # Spatial (MUST BE INTEGERS)
  vision_radius: 5            # Integer!
  interaction_radius: 1       # Integer!
  move_budget_per_tick: 2     # Integer!
  
  # Resources
  forage_rate: 1              # Integer harvest per tick
  resource_growth_rate: 1     # Integer regeneration per tick
  resource_regen_cooldown: 5  # Integer ticks
  
  # Trading
  trade_cooldown_ticks: 10    # Integer ticks
  beta: 0.95                  # Foraging discount factor (float)

resources:
  A:
    density: 0.1              # Probability of cell having resource
    amount: 5                 # Integer per cell
  B:
    density: 0.1
    amount: 5

# Optional: mode scheduling
mode_schedule:
  type: "global_cycle"
  forage_ticks: 10            # Integer
  trade_ticks: 10             # Integer
  start_mode: "forage"        # or "trade"
```

#### Creating New Test Scenarios (STRICT REQUIREMENTS)

**For test scenarios with <10 agents, EVERY agent must have a UNIQUE utility function.**

Use the **complementary pairing pattern** (algorithm):

1. **Agent 2k-1** (odd: 1, 3, 5, ...): Randomly assign utility type
   - If **Linear**: 
     - vA ~ Uniform(0.1, 0.9)
     - **vB = 1 - vA** (exactly 1.0, not ≈)
   - If **CES**: 
     - rho ~ Uniform(-2.0, 0.99)
     - wA ~ Uniform(0.1, 0.9)
     - **wB = 1 - wA** (exactly 1.0, not ≈)

2. **Agent 2k** (even: 2, 4, 6, ...): Complementary to Agent 2k-1
   - **Same utility type** as paired agent
   - **Reverse preferences**:
     - Linear: If 2k-1 has (vA, vB), then 2k gets (vB, vA)
     - CES: If 2k-1 has (rho₁, wA, wB), then 2k gets (rho₂, wB, wA) where rho₂ ~ Uniform(-2.0, 0.99)

3. Repeat: Agent 3 random → Agent 4 complements 3 → Agent 5 random → etc.

**Initial endowments:**
- Each good (A, B, M), each agent: independently from Uniform(1, 50), round to integer

**Strict normalization:**
- Linear: **vA + vB = 1.0** (exactly)
- CES: **wA + wB = 1.0** (exactly)
- CES: **rho ∈ (-2.0, 0.99]** (strictly avoid rho=1.0)
- Mix weights: **∑weights = 1.0** (exactly; use 1/N for N agents)

**Test parameter defaults (ALWAYS use these):**
- **interaction_radius: 1** (always 1 in tests, never higher)
- **move_budget_per_tick: 1** (always 1 in tests, never higher)
- vision_radius: Can vary, typically 5-10
- spread: Typically 0.0-0.1
- dA_max: Typically 3-5
- epsilon: Typically 0.001

**Example for 4-agent scenario:**
```yaml
utilities:
  mix:
    # Agent 1 (random linear)
    - {type: linear, weight: 0.25, params: {vA: 0.73, vB: 0.27}}
    # Agent 2 (complement to 1)
    - {type: linear, weight: 0.25, params: {vA: 0.27, vB: 0.73}}
    # Agent 3 (random CES)
    - {type: ces, weight: 0.25, params: {rho: -0.42, wA: 0.81, wB: 0.19}}
    # Agent 4 (complement to 3, new rho)
    - {type: ces, weight: 0.25, params: {rho: 0.65, wA: 0.19, wB: 0.81}}

initial_inventories:
  A: [23, 7, 41, 15]   # Each ~ Uniform(1, 50)
  B: [8, 32, 19, 5]    # Independent draws
  M: [0, 87, 34, 12]   # For monetary scenarios
```

**Verification checklist:**
- ✅ vA + vB = 1.0 for all linear utilities (0.73+0.27=1.0, 0.27+0.73=1.0)
- ✅ wA + wB = 1.0 for all CES utilities (0.81+0.19=1.0, 0.19+0.81=1.0)
- ✅ All 4 utilities are unique (different parameters)
- ✅ Complementary pairs guarantee gains from trade
- ✅ weights sum to 1.0 (4 × 0.25 = 1.0)

**Why this is REQUIRED:**
- Identical agents → identical MRS → zero gains from trade
- Homogeneity makes tests non-deterministic (no trades → agents wander randomly)
- Complementary pairing guarantees mutual benefit exists
- Essential for monetary scenarios where heterogeneity creates liquidity

**GUI Integration (Future):**
This pattern should be implemented in Launcher GUI as checkbox in Basic Settings tab.
- See [.cursor/rules/gui-development.mdc](mdc:.cursor/rules/gui-development.mdc) for implementation spec
- When enabled: Auto-generates utilities and endowments per algorithm above
- Saves user time and guarantees economic validity

**Reference scenarios:**
- ✅ [scenarios/money_test_basic.yaml](mdc:scenarios/money_test_basic.yaml) - Follows pattern
- ✅ [scenarios/three_agent_barter.yaml](mdc:scenarios/three_agent_barter.yaml) - Uses mix
- ❌ **NEVER CREATE**: Agents with identical utilities and endowments

#### Common Mistakes

- ❌ Using float for `vision_radius` or other spatial params (MUST be int)
- ❌ Utility weights not summing to 1.0
- ❌ Using `ΔA_max` instead of `dA_max` (legacy name)
- ❌ Float inventories or resource amounts (MUST be int)
- ❌ **CRITICAL: interaction_radius > 1 in tests** - ALWAYS use interaction_radius: 1 in test scenarios
- ❌ **CRITICAL: move_budget_per_tick > 1 in tests** - ALWAYS use move_budget_per_tick: 1 in test scenarios
- ❌ **CRITICAL: Homogeneous agents in test scenarios** - Every agent must have unique utility function
  - Never use same utility parameters for multiple agents in tests
  - Must follow complementary pairing pattern above
  - Homogeneity eliminates gains from trade → tests won't exercise code

### Telemetry System (SQLite Logging)

Telemetry logs all simulation data to `./logs/telemetry.db` using SQLite.

#### Core Files

- **Database**: [src/telemetry/database.py](mdc:src/telemetry/database.py) - Schema definitions, table creation
- **Loggers**: [src/telemetry/db_loggers.py](mdc:src/telemetry/db_loggers.py) - Batched logging logic
- **Config**: [src/telemetry/config.py](mdc:src/telemetry/config.py) - `LogConfig` levels (STANDARD, DEBUG)

#### Log Levels

```python
from telemetry.config import LogConfig

# STANDARD: Comprehensive production logging (default)
# Includes: trades, decisions, agent snapshots, resource snapshots
sim = Simulation(scenario, seed=42, log_config=LogConfig.standard())

# DEBUG: Adds failed trade attempt logging (creates large databases)
sim = Simulation(scenario, seed=42, log_config=LogConfig.debug())

# OFF: No database logging (for performance benchmarks)
sim = Simulation(scenario, seed=42, log_config=LogConfig(use_database=False))
```

#### Database Schema

**Tables** (see [src/telemetry/database.py](mdc:src/telemetry/database.py)):
- `runs` - Simulation metadata
- `agents` - Agent snapshots per tick
- `trades` - All trade events
- `decisions` - Agent decisions per tick
- `resources` - Resource cell states

#### Critical Database Gotcha

**After modifying schema, MUST delete old database:**

```bash
rm logs/telemetry.db
pytest -q
```

**When to delete:**
- After changing table definitions in `database.py`
- After adding/removing columns in logging code
- After changing field types

#### Adding New Telemetry

1. **Update schema** in [src/telemetry/database.py](mdc:src/telemetry/database.py):
   ```python
   CREATE TABLE IF NOT EXISTS your_table (
       run_id INTEGER NOT NULL,
       tick INTEGER NOT NULL,
       your_field TEXT,
       ...
       FOREIGN KEY (run_id) REFERENCES runs(run_id)
   )
   ```

2. **Add buffer** in [src/telemetry/db_loggers.py](mdc:src/telemetry/db_loggers.py):
   ```python
   self.your_table_buffer = []
   ```

3. **Add logging method**:
   ```python
   def log_your_event(self, ...):
       if self.config.level >= LogLevel.STANDARD:
           self.your_table_buffer.append((
               self.run_id, self.tick, field1, field2, ...
           ))
   ```

4. **Add flush method**:
   ```python
   def _flush_your_table(self):
       if self.your_table_buffer:
           self.db.executemany("""
               INSERT INTO your_table
               (run_id, tick, field1, field2, ...)
               VALUES (?, ?, ?, ?, ...)
           """, self.your_table_buffer)
           self.your_table_buffer.clear()
   ```

5. **Call flush** in `_flush_all_buffers()` and `finalize_run()`

6. **Delete old DB**: `rm logs/telemetry.db`

7. **Test**: Run simulation and verify data in DB

#### Viewing Telemetry

```bash
# GUI log viewer
python view_logs.py

# Programmatic access
import sqlite3
conn = sqlite3.connect("logs/telemetry.db")
cursor = conn.cursor()
cursor.execute("SELECT * FROM trades WHERE run_id = ?", (42,))
trades = cursor.fetchall()
```

#### Performance Considerations

- Batching reduces DB overhead (buffers flush at end of tick)
- STANDARD level is optimized for production use (~13-39% overhead depending on scenario)
- DEBUG level creates very large databases (use for short runs only)
- Use `use_database=False` for performance benchmarks (0% overhead)
- Consider periodic cleanup of old logs

#### Common Telemetry Mistakes

- ❌ Forgetting to flush new buffer in `_flush_all_buffers()`
- ❌ Not deleting `logs/telemetry.db` after schema changes
- ❌ Using DEBUG level for long runs (creates very large databases)
- ❌ Not handling NULL values in optional fields
- ❌ Breaking foreign key relationships
