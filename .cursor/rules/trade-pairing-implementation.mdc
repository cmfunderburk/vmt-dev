---
description: Trade pairing implementation guide - three-pass algorithm for efficient bilateral matching
---

# Trade Pairing Implementation Guide

**Reference**: [docs/tmp/pairing/FINAL_PAIRING.md](mdc:docs/tmp/pairing/FINAL_PAIRING.md)

## Overview

Trade pairing replaces O(N²) all-pairs matching with O(N) three-pass algorithm in [DecisionSystem](mdc:src/vmt_engine/systems/decision.py).

**Core concept**: Agents pair up before movement/trade, remain paired across multiple ticks until trade opportunities exhausted.

---

## Critical Implementation Rules

### 1. Pairing Persistence (CRITICAL FOR PERFORMANCE)

**Agents remain paired until trade attempt fails:**
```python
# In TradeSystem.execute() - trade_pair()
result = find_compensating_block(agent_i, agent_j, params)

if result is None:
    # ONLY unpair when opportunities exhausted
    agent_i.paired_with_id = None
    agent_j.paired_with_id = None
    # Set cooldown
else:
    # Execute trade but KEEP pairing intact
    execute_trade(agent_i, agent_j, result)
    # NO unpair here! They trade again next tick
```

**Never unpair after successful trade** - this would destroy the O(N) performance benefit.

---

### 2. Three-Pass Algorithm Structure

**Pass 1: Target Selection** (in ID order)
- Paired agents: Validate pairing, lock target to partner, **still build preference list for telemetry**
- Unpaired agents: Build ranked preference list using beta-discounted surplus

**Pass 2: Mutual Consent** (in ID order)
- Check `partner.target_agent_id == agent.id` using **current tick data** (set in Pass 1)
- Only lower-ID agent establishes pairing (avoid duplication)
- Log both `surplus_i` and `surplus_j`

**Pass 3: Surplus-Based Greedy Fallback**
- Collect ALL (agent, partner, discounted_surplus) tuples
- Sort by `(-discounted_surplus, agent_id, partner_id)`
- Greedily assign pairs (welfare-maximizing)

---

### 3. Distance Discounting Formula

**Use beta discount factor** (same as foraging):
```python
beta = sim.params.get("beta", 0.95)
distance = abs(agent.pos[0] - neighbor_pos[0]) + abs(agent.pos[1] - neighbor_pos[1])
discounted_surplus = surplus * (beta ** distance)
```

**Preference list structure**: `[(neighbor_id, surplus, discounted_surplus, distance), ...]`

---

### 4. Agent Data Structure

Add to [Agent](mdc:src/vmt_engine/core/agent.py):
```python
# NEW: Pairing state (persists across ticks)
paired_with_id: Optional[int] = field(default=None, repr=False)

# INTERNAL: Decision context (cleared each tick)
_preference_list: list[tuple[int, float, float, int]] = field(default_factory=list, repr=False)
_decision_target_type: Optional[str] = field(default=None, repr=False)
```

---

### 5. Phase Integrations

**DecisionSystem** ([decision.py](mdc:src/vmt_engine/systems/decision.py)):
- Refactor to three passes: `_pass1_target_selection()`, `_pass2_mutual_consent()`, `_pass3_best_available_fallback()`, `_pass4_log_decisions()`

**MovementSystem** ([movement.py](mdc:src/vmt_engine/systems/movement.py)):
```python
if agent.paired_with_id is not None:
    target_pos = sim.agent_by_id[agent.paired_with_id].pos
else:
    target_pos = agent.target_pos
```

**TradeSystem** ([trading.py](mdc:src/vmt_engine/systems/trading.py)):
- Process ONLY paired agents (skip unpaired)
- Check distance ≤ interaction_radius before trade
- Unpair ONLY on trade failure (opportunities exhausted)
- Remain paired after successful trade

**ForageSystem** ([foraging.py](mdc:src/vmt_engine/systems/foraging.py)):
```python
if agent.paired_with_id is not None:
    continue  # Paired agents don't forage
```

**HousekeepingSystem** ([housekeeping.py](mdc:src/vmt_engine/systems/housekeeping.py)):
- Add `_verify_pairing_integrity()` check
- Detect asymmetric pairings and repair

**Mode switching**:
- Clear all pairings when `current_mode` changes
- No cooldowns on mode-switch unpairings

---

### 6. Telemetry Schema Updates

**Modified `decisions` table** ([db_loggers.py](mdc:src/telemetry/db_loggers.py)):
- Add column: `is_paired INTEGER` (1 if paired, 0 if not)
- Remove `alternatives` column (moved to preferences table)

**New `pairings` table**:
```sql
CREATE TABLE pairings (
    tick INTEGER,
    agent_i INTEGER,
    agent_j INTEGER,
    event TEXT,        -- "pair" or "unpair"
    reason TEXT,       -- "mutual_consent", "fallback_rank_0_surplus_0.6500", "trade_failed"
    surplus_i REAL,    -- Agent i's surplus with j
    surplus_j REAL,    -- Agent j's surplus with i
    PRIMARY KEY (tick, agent_i, agent_j, event)
)
```

**New `preferences` table**:
```sql
CREATE TABLE preferences (
    tick INTEGER,
    agent_id INTEGER,
    partner_id INTEGER,
    rank INTEGER,              -- 0 = top choice
    surplus REAL,              -- Undiscounted
    discounted_surplus REAL,   -- Beta-discounted
    distance INTEGER,          -- Manhattan distance
    PRIMARY KEY (tick, agent_id, partner_id)
)
```

**Logging behavior**:
- Default: Log top 3 preferences per agent per tick
- With `log_full_preferences: True` scenario parameter: Log all preferences
- Always log both `surplus_i` and `surplus_j` for pairings

---

### 7. Key Invariants to Maintain

✅ **Pairing symmetry**: If `A.paired_with_id == B`, then `B.paired_with_id == A`  
✅ **Persistence**: Pairings survive across ticks until trade failure  
✅ **Determinism**: All loops iterate agents in ID order  
✅ **Cooldown filtering**: Paired agents can't have cooled-down partners (filtered in Pass 1)  
✅ **Exclusive commitment**: Paired agents move toward partner, don't forage  
✅ **Telemetry completeness**: Log pairing events, preferences, and decisions

---

### 8. Testing Checklist

Before merging, verify:
1. ✅ Mutual consent pairing works
2. ✅ Fallback pairing (surplus-based greedy) works
3. ✅ Agents remain paired after successful trade
4. ✅ Agents unpair only when trade fails
5. ✅ Cooldown prevents re-pairing
6. ✅ Mode switch clears pairings
7. ✅ Paired agents don't forage
8. ✅ Pairing integrity checks catch corruption
9. ✅ Telemetry logs all events correctly
10. ✅ Determinism: same seed → identical results (100 runs)
11. ✅ Performance: 5-8× speedup in trade phase
12. ✅ Backward compatibility: existing scenarios work

---

### 9. Common Pitfalls to Avoid

❌ **Unpair after successful trade** → Destroys O(N) benefit  
❌ **Single-pass mutual consent** → One-tick lag problem  
❌ **ID-based fallback matching** → Not welfare-maximizing  
❌ **Log single surplus** → Ambiguous for mutual pairings  
❌ **Paired agents build preferences but don't act** → Forgot to check `paired_with_id` in Pass 1 target setting  
❌ **Forget to clear cooldowns on pairing** → Prevents re-pairing after cooldown expires  
❌ **Unsorted agent iteration** → Breaks determinism

---

### 10. Migration Path

Follow 8-phase plan in specification:
1. Add Agent fields (no behavior change)
2. Refactor DecisionSystem structure (empty passes)
3. Implement Pass 2 (mutual consent)
4. Implement Pass 3 (fallback)
5. Integrate other phases (Movement, Trade, Forage)
6. Add mode management
7. Add Housekeeping integrity checks
8. Performance validation and benchmarking

---

## Quick Reference

**When to unpair:**
- ✅ Trade attempt fails (opportunities exhausted)
- ✅ Mode switches
- ✅ Pairing corruption detected (defensive)
- ❌ NEVER after successful trade

**When to clear cooldown:**
- ✅ Pairing established (mutual or fallback)
- ❌ NOT on mode-switch unpair

**Preference list format:**
```python
[(partner_id, surplus, discounted_surplus, distance), ...]
# Sorted by (-discounted_surplus, partner_id)
```

**Telemetry logging:**
```python
# Pairing
log_pairing_event(tick, agent_i, agent_j, "pair", reason, surplus_i, surplus_j)

# Preferences (top 3 by default)
log_preference(tick, agent_id, partner_id, rank, surplus, discounted_surplus, distance)
```

---

## Performance Expectations

With persistent pairing until exhaustion:
- **Decision phase**: O(3N·k) where k = neighbors → O(N)
- **Trade phase**: O(P) where P = paired count → O(N/2) best case
- **Overall**: 5-8× speedup in typical scenarios
- **Best case**: 10-15× speedup with high pairing rates and repeated trades
