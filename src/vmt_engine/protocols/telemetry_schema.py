"""
Telemetry Schema Extensions for Protocol System

This module defines the database schema extensions needed to support protocol
telemetry logging. These tables track:
- Which protocols were used in each run
- Effect history for debugging and analysis
- Protocol-specific state updates

Version: 2025.10.26 (Phase 0 - Infrastructure)
"""

# SQL schema for protocol telemetry tables
# These will be integrated into src/telemetry/database.py in Phase 2


PROTOCOL_RUNS_TABLE = """
CREATE TABLE IF NOT EXISTS protocol_runs (
    run_id TEXT NOT NULL,
    protocol_type TEXT NOT NULL,  -- 'search' | 'matching' | 'bargaining'
    protocol_name TEXT NOT NULL,  -- e.g., 'three_pass_matching'
    protocol_version TEXT NOT NULL,  -- e.g., '2025.10.26'
    
    PRIMARY KEY (run_id, protocol_type),
    FOREIGN KEY (run_id) REFERENCES simulation_runs(run_id)
);
"""


EFFECTS_TABLE = """
CREATE TABLE IF NOT EXISTS effects (
    run_id TEXT NOT NULL,
    tick INTEGER NOT NULL,
    effect_type TEXT NOT NULL,  -- 'Pair' | 'Trade' | 'Move' | etc.
    protocol_name TEXT NOT NULL,
    
    -- Agent references (nullable for effects that don't involve agents)
    agent_id INTEGER,
    agent_a INTEGER,
    agent_b INTEGER,
    
    -- Effect-specific data (stored as JSON for flexibility)
    effect_data TEXT NOT NULL,  -- JSON serialization of effect fields
    
    -- Indexing
    PRIMARY KEY (run_id, tick, effect_type, agent_id),
    FOREIGN KEY (run_id) REFERENCES simulation_runs(run_id)
);
"""


PROTOCOL_STATE_TABLE = """
CREATE TABLE IF NOT EXISTS protocol_state (
    run_id TEXT NOT NULL,
    tick INTEGER NOT NULL,
    protocol_name TEXT NOT NULL,
    agent_id INTEGER NOT NULL,
    state_key TEXT NOT NULL,
    state_value TEXT NOT NULL,  -- JSON serialization of value
    
    PRIMARY KEY (run_id, tick, protocol_name, agent_id, state_key),
    FOREIGN KEY (run_id) REFERENCES simulation_runs(run_id)
);
"""


# Index definitions for performance
PROTOCOL_INDEXES = [
    "CREATE INDEX IF NOT EXISTS idx_effects_tick ON effects(run_id, tick);",
    "CREATE INDEX IF NOT EXISTS idx_effects_agent ON effects(run_id, agent_id);",
    "CREATE INDEX IF NOT EXISTS idx_protocol_state_tick ON protocol_state(run_id, tick);",
]


def get_protocol_schema() -> list[str]:
    """
    Get all protocol-related SQL schema statements.
    
    Returns:
        List of SQL statements to create protocol tables and indexes
    """
    return [
        PROTOCOL_RUNS_TABLE,
        EFFECTS_TABLE,
        PROTOCOL_STATE_TABLE,
    ] + PROTOCOL_INDEXES


# =============================================================================
# Documentation
# =============================================================================

"""
Protocol Telemetry Schema Documentation

## protocol_runs table

Records which protocols were used in each simulation run.

Columns:
- run_id: Foreign key to simulation_runs
- protocol_type: Which phase this protocol handles
- protocol_name: Protocol identifier
- protocol_version: Date-based version for reproducibility

Example row:
    run_id='2025-10-26_12-34-56'
    protocol_type='matching'
    protocol_name='three_pass_matching'
    protocol_version='2025.10.26'


## effects table

Records all effects generated by protocols during simulation.

Columns:
- run_id: Foreign key to simulation_runs
- tick: When effect was generated
- effect_type: Type of effect (Pair, Trade, Move, etc.)
- protocol_name: Which protocol generated this effect
- agent_id: Primary agent (for single-agent effects)
- agent_a, agent_b: Agent pair (for pair effects)
- effect_data: JSON serialization of effect-specific fields

Example row (Pair effect):
    run_id='2025-10-26_12-34-56'
    tick=10
    effect_type='Pair'
    protocol_name='three_pass_matching'
    agent_a=0
    agent_b=1
    effect_data='{"reason": "mutual_consent"}'

Example row (Trade effect):
    run_id='2025-10-26_12-34-56'
    tick=11
    effect_type='Trade'
    protocol_name='compensating_block'
    agent_a=0
    agent_b=1
    effect_data='{"pair_type": "A_for_B", "dA": -5, "dB": 3, "price": 1.67, ...}'


## protocol_state table

Records multi-tick protocol state (e.g., Rubinstein negotiation round number).

Columns:
- run_id: Foreign key to simulation_runs
- tick: When state was updated
- protocol_name: Which protocol owns this state
- agent_id: Which agent's state
- state_key: State variable name
- state_value: JSON serialization of value

Example row (Rubinstein bargaining):
    run_id='2025-10-26_12-34-56'
    tick=10
    protocol_name='rubinstein_alternating'
    agent_id=0
    state_key='round_number'
    state_value='3'

Example row (Memory-based search):
    run_id='2025-10-26_12-34-56'
    tick=15
    protocol_name='memory_based_search'
    agent_id=2
    state_key='price_map'
    state_value='{"(5,10)": 1.5, "(12,8)": 2.1}'


## Usage Notes

1. **Phase 0 (Infrastructure):** Schema defined but not yet integrated
2. **Phase 1 (Legacy Adapters):** Legacy protocols will not log to these tables
   (they will use existing telemetry for backward compatibility)
3. **Phase 2 (Core Integration):** Effect logging integrated into simulation core
4. **Phase 3+ (Alternative Protocols):** New protocols log all effects to these tables

## Integration with Existing Telemetry

Protocol telemetry is ADDITIVE - existing telemetry tables remain unchanged:
- simulation_runs: Unchanged
- agent_snapshots: Unchanged
- trades: Unchanged (but will also be logged as Trade effects)
- preferences: Unchanged (but will also be logged as effects)
- pairings: Unchanged (but will also be logged as Pair/Unpair effects)

The effects table provides a unified view of all protocol actions, while existing
tables maintain backward compatibility.
"""

